
# [좋은 변수, 함수 이름 만들기](https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=vicfaith&logNo=221166340935)

[![프로필](https://ssl.pstatic.net/static/blog/m/img_default.gif)](https://m.blog.naver.com/PostList.naver?blogId=vicfaith)

[**vicfaith**](https://m.blog.naver.com/PostList.naver?blogId=vicfaith)

2017. 12. 19. 8:31

[이웃추가](https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=vicfaith&logNo=221166340935#)

본문 기타 기능

프로그램을 짤 때 좋은 변수, 함수 이름은 좋은 코딩 스타일과 더불어 기본 중의 기본이다.

각 회사마다 명명 규칙(Naming Convention)이 있을 것이다. 하지만 영어로 코딩을 하다 보니 간결하면서도 내용을 설명하는 좋은 이름을 짓는 것은 그리 간단한 일은 아니다.

자신이 작성하지 않은 코드를 변경하고 문서화되지 않은 복잡한 코드를 수정하는 것은 개발자에게 항상 일어나는 일이다. 스타일이 맞지 않거나 변수, 함수 이름이 무슨 뜻인지 알기 어려운 경우는 코드를 읽고 이해하는데 어려움이 많다. 가독성 높은 코드는 누군가에게 그 자체로 좋은 문서화의 기능을 한다.

​

여기 가독성을 높이기 위한 명명 규칙 몇 가지 원칙을 들어본다.

​

**1. 일관적이어야 한다.**

팀의 코딩 가이드라인은 반드시 따라야 하는 법은 아니지만 특별한 일이 없으면 따라야 하는 룰이다.

가끔 자기가 생각하는 이름이 더 좋다는 개발자가 있기 마련이다. 원칙이 있으면 개인적인 생각들로 인한 논란을 피하는 데 도움이 된다. 자신이 생각하는 스타일이 더 좋다고 생각되는 경우 팀 회의를 거쳐 가이드라인을 바꾸거나 적어도 리뷰시 문제 될 것 이 없는 대안 옵션으로 만들어라.

​

**2. 문법에 맞아야 한다.**

Class name으로 CardAddView와 AddCardView 어떤 쪽이 자연스러운가?

AddCardView가 더 자연스럽다. TakePhotoActivity와 PhotoTakeActivity에서도 동사 + 명사 형태인 TakePhotoActivity가 더 자연스럽다.

​

함수 이름의 경우도 doSomething처럼 능동형으로 이름을 짓는 것이 좋다.

isValidEmail()이 isEmailValid() 보다 읽기가 편하다.

deliveryAddressSetSuccessfully()보다는 setDeliveryAddressSuccessfully() 이 더 매끄럽다.

하지만 이것보다는 selectedDeliveryAddress처럼 능동형으로 함수 이름을 만들면 읽고 이해하기가 더 쉬울 것이다.

​

Callback 함수 이름은 아래처럼 수동형으로 만드는 것이 보편적이다.

deliveryAddressSelected()

onDeliveryAddressSelected()

onViewClicked()

onEventTriggered()

​

**3. 간결해야 한다.**

너무 긴 이름은 읽기도 어렵고 그만큼 많은 일을 한다는 의미이므로 작은 함수들도 나누는 것이 좋다.

가능한 한가지 일만을 하도록 함수를 만들자.

​

void showCurrentlySelectedAddress()

boolean canLogin()

void handleUserInput();

void handleLoginFailure();

void cancelAllRequest();

boolean isValidEmail();

boolean shouldShowError()보다는 boolean checkError(); 가 더 자연스럽다.

**4. 명시적이어야 한다.**

간결하되 내용을 잘 기술하여야 한다.

​

xxx**provider** : 어떤 역할을 하는 오브젝트를 제공하는 경우 ...provider suffix는 유용하다.

ex) modelProvider, locationProvider, EventProvider

boolean clientTokenPresent;

boolean requestPerformed;

long tooltipDurationInMillis

​

void showPreviouslyUsedAddresses()

void notifyPreviousAddressChanged()

void searchByPostCode()

void hasFecthedPaymentMethods()

void sendAnalyticsEvent(String event);

void showBooks**IfNeeded**(); //함수 내부적으로 조건에 따라 기능이 달라지는 경우 ifNeeded, ifNecessary 등을 붙이면 더 가독성이 높다.

void updateData**After**Login

**5. 적절한 단어를 사용해야 한다.**

비슷한 단어를 섞어 쓰기보다 하나로 통일하는 것이 일관적이다.

예를 들어 데이터를 로딩하는 함수를 loadData, fetchData, requestData 중에서 하나로 통일하는 것이 좋다.

​

(load | fetch) + Data

get + Something

(perform | request) + Something

(create|make) + Something

handle + Something (Event | Data | Response |...)

(populate | inflate) + (View | Screen)

(authenticate | authorise) + User

(init | setup) Views

calculateWage()

clearAddressFields()

​

**6. 유명한 오픈 소스를 공부하라.**

혼자서 좋은 이름을 생각하는 데는 한계가 있다. 좋은 오픈 소스를 통해 좋은 작명법을 배우는 것이 필요하다..

​----

# [좋은 코드를 위한 자바 메서드 네이밍](https://tecoble.techcourse.co.kr/post/2020-04-26-Method-Naming/)

-   ![](data:image/jpeg;base64,/9j/2wBDAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQH/2wBDAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQH/wgARCAAUABQDASIAAhEBAxEB/8QAGAABAQEBAQAAAAAAAAAAAAAAAAcIBAX/xAAWAQEBAQAAAAAAAAAAAAAAAAAFBgf/2gAMAwEAAhADEAAAAeGeXLy9dx/QCegWMu4JJqst4fnv/8QAHBAAAgMAAwEAAAAAAAAAAAAABAUCBgcAAQMS/9oACAEBAAEFAl+ToWALHFgQz0+LogAVV77nEp7Ayyl687+6gWc7dsbxY48r7M/yS//EACMRAAICAgEDBQEAAAAAAAAAAAECAxEEEgUAITETFCMyUoH/2gAIAQMBAT8B4tuXm5OeKPKy0i2yGj9xFcIINxwxmYsoBK6oI7oMx+vcLwmY6hpOXxVkYW6yGTcMfIfSFl2Bu6JF9ZAC8gyqNVXIm1VeyrXqVQHYfzqVVM0pKqflk8gfvr//xAAnEQACAAMGBgMAAAAAAAAAAAABAgMEEQASFCEiQQUTFTJCUTFDkf/aAAgBAgEBPwHiTSJlFbDScR1SGHw7lYt2txo0S4is3eC5c1yWgrWvVH+uRATxFQNO2RYH9FuHMxgTLFmLYSVzJJOrl3s/nV5e97QlHLh5DsTb2qVt/8QAJhAAAgIBBAEEAgMAAAAAAAAAAgMBBAUAERITIRQjJDIiMTNBkf/aAAgBAQAGPwKyq3jui8vJZRDbdFzKxiYWZ9vqCfTkCCkkgEr4wIREeNKTXzNjraqsXp7SapW/m5StiFmmVyuGhXdaFzZNEcxDrg1kfMV1+vtmJmSa3F4SwxpbDEmbL+PyD5Kdv138BjaAAI1bmtkwsGeWyxFFbHtu8yLIP9yJqVXBwZ9lzyiJHzHjSclapNjJ0q1Ooq8SoqySFXq+WXVbUYqNmRZWJCw/yisTV8Y7dxA8adl1NqoNTkYMbKGzBmphJetDVuXDFmEGtkhMhPHxrI4Nl61RoVLjTEKBiBsO04XvNk2QtRBGywwpJApnef8AbGPG6Q7Wbvzd2zf+28SLibILIeGwEpSyGCOInzrHCNln8JzMlsREU2HciIp8yRf3r//EABkQAQEBAAMAAAAAAAAAAAAAAAERACExQf/aAAgBAQABPyGmBAv9cZ5KUAa4wkKrXgNc9m+bLjDwPp+MHIq1G3pETe0KQZo2JWsZw1uFOJTgQVCRlKFjgRZTyz9z0Va54phWKElSWUPVSSpy+DVDldXoDjf/2gAMAwEAAgADAAAAEF/Ag//EABkRAQEBAAMAAAAAAAAAAAAAAAERACExYf/aAAgBAwEBPxAsbLnsxiwQQUOynwY5yyuATAg8RBMIEEoJhEIACE6M8kbKl9qV3//EABoRAQADAQEBAAAAAAAAAAAAAAERITEAUUH/2gAIAQIBAT8QlYTVhEhQFqEgY7NfwsUoAEV4Nknr6k60pnUqs622ngxnLsAtCzVVXVVbe//EABgQAQEBAQEAAAAAAAAAAAAAAAEAESEx/9oACAEBAAE/EEvu9ITIeNFGC6QxucEVsWgw/D67tN/ad0LlIiN3jnvEkmg7kBgn30RXErNpYJRPcYnIwpUq8qxc8Me7MZZgQDoQCCvNojRfhGnSvRLBgf/Z)![](https://tecoble.techcourse.co.kr/static/dc549e08fc27699127f47060a32e80ca/f86e8/tigger.jpg)
    
    ## 2기_티거
    
    우아한테크코스 2기 티거(김준석)입니다 :)
    
    [More posts](https://tecoble.techcourse.co.kr/author/2-%EA%B8%B0-%ED%8B%B0%EA%B1%B0/)  by  2기_티거.
    
    [](https://tecoble.techcourse.co.kr/author/2-%EA%B8%B0-%ED%8B%B0%EA%B1%B0/)
    
    ![2기_티거](data:image/jpeg;base64,/9j/2wBDAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQH/2wBDAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQH/wgARCAAUABQDASIAAhEBAxEB/8QAGAABAQEBAQAAAAAAAAAAAAAAAAcIBAX/xAAWAQEBAQAAAAAAAAAAAAAAAAAFBgf/2gAMAwEAAhADEAAAAeGeXLy9dx/QCegWMu4JJqst4fnv/8QAHBAAAgMAAwEAAAAAAAAAAAAABAUCBgcAAQMS/9oACAEBAAEFAl+ToWALHFgQz0+LogAVV77nEp7Ayyl687+6gWc7dsbxY48r7M/yS//EACMRAAICAgEDBQEAAAAAAAAAAAECAxEEEgUAITETFCMyUoH/2gAIAQMBAT8B4tuXm5OeKPKy0i2yGj9xFcIINxwxmYsoBK6oI7oMx+vcLwmY6hpOXxVkYW6yGTcMfIfSFl2Bu6JF9ZAC8gyqNVXIm1VeyrXqVQHYfzqVVM0pKqflk8gfvr//xAAnEQACAAMGBgMAAAAAAAAAAAABAgMEEQASFCEiQQUTFTJCUTFDkf/aAAgBAgEBPwHiTSJlFbDScR1SGHw7lYt2txo0S4is3eC5c1yWgrWvVH+uRATxFQNO2RYH9FuHMxgTLFmLYSVzJJOrl3s/nV5e97QlHLh5DsTb2qVt/8QAJhAAAgIBBAEEAgMAAAAAAAAAAgMBBAUAERITIRQjJDIiMTNBkf/aAAgBAQAGPwKyq3jui8vJZRDbdFzKxiYWZ9vqCfTkCCkkgEr4wIREeNKTXzNjraqsXp7SapW/m5StiFmmVyuGhXdaFzZNEcxDrg1kfMV1+vtmJmSa3F4SwxpbDEmbL+PyD5Kdv138BjaAAI1bmtkwsGeWyxFFbHtu8yLIP9yJqVXBwZ9lzyiJHzHjSclapNjJ0q1Ooq8SoqySFXq+WXVbUYqNmRZWJCw/yisTV8Y7dxA8adl1NqoNTkYMbKGzBmphJetDVuXDFmEGtkhMhPHxrI4Nl61RoVLjTEKBiBsO04XvNk2QtRBGywwpJApnef8AbGPG6Q7Wbvzd2zf+28SLibILIeGwEpSyGCOInzrHCNln8JzMlsREU2HciIp8yRf3r//EABkQAQEBAAMAAAAAAAAAAAAAAAERACExQf/aAAgBAQABPyGmBAv9cZ5KUAa4wkKrXgNc9m+bLjDwPp+MHIq1G3pETe0KQZo2JWsZw1uFOJTgQVCRlKFjgRZTyz9z0Va54phWKElSWUPVSSpy+DVDldXoDjf/2gAMAwEAAgADAAAAEF/Ag//EABkRAQEBAAMAAAAAAAAAAAAAAAERACExYf/aAAgBAwEBPxAsbLnsxiwQQUOynwY5yyuATAg8RBMIEEoJhEIACE6M8kbKl9qV3//EABoRAQADAQEBAAAAAAAAAAAAAAERITEAUUH/2gAIAQIBAT8QlYTVhEhQFqEgY7NfwsUoAEV4Nknr6k60pnUqs622ngxnLsAtCzVVXVVbe//EABgQAQEBAQEAAAAAAAAAAAAAAAEAESEx/9oACAEBAAE/EEvu9ITIeNFGC6QxucEVsWgw/D67tN/ad0LlIiN3jnvEkmg7kBgn30RXErNpYJRPcYnIwpUq8qxc8Me7MZZgQDoQCCvNojRfhGnSvRLBgf/Z)![2기_티거](https://tecoble.techcourse.co.kr/static/dc549e08fc27699127f47060a32e80ca/f86e8/tigger.jpg)
    

#### [2기_티거](https://tecoble.techcourse.co.kr/author/2-%EA%B8%B0-%ED%8B%B0%EA%B1%B0/)

26 APR 2020•  4  MIN READ

![좋은 코드를 위한 자바 메서드 네이밍](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAABYlAAAWJQFJUiTwAAABZ0lEQVQoz81TS0sCYRQdercN+glBtCiyohLJRUFEr9/ZJq2gVT7yVUGFTkUzpjOTjo9R56GOEgWdvvmmqUCxFi5aHO75zoVz7+Xejxm5O0E/wfTdcJg9hoVR8hgjcGIv3k2zzCyfrw6ZlB9M8tCOKd83T/psOJzm/R35QWJGfYYIsTDFncErJTDDBzD/FIZHjGOaaCtCDMtClHJPNobZdIhiTUxQbSkTgZvoE/en1JShFVg/DrQc3ms6gnoJcruJuqoi2lJRUmvgSzJibRV4ecVtvYoHU4dZqSLUUJDXVZiGgW3xwu7WNjyCT83jLVdApCaj3DBgFIq4bmkoyDI4MYubtg40TLBaGZmmBkN6RtxQUKwoMBUFe8KnodWmhTk+iH3pCotcEN5MlFZ0PQawKSSwQUZaIPoO4at8GO70OXalS7i4ANZJbisbx6Qzcs+lsM4ifl/KgLOUn2cz3uU0/oqOs/m3P+UDdeOP4EhHm1IAAAAASUVORK5CYII=)![좋은 코드를 위한 자바 메서드 네이밍](https://tecoble.techcourse.co.kr/static/60146897ed1ac59a907c3e0091aaf193/6a713/naming.png)

## 네이밍이 중요한 이유

> 클린 코드 참조

코드를 작성한 의도와 목적이 명확해야 하며 다른 사람이 쉽게 읽을 수 있어야 하기 때문이다.

왜 그래야 하나?

코드의 가독성이 좋아진다.

그러면 뭐가 좋나?

다른 사람이 코드를 이해하는데 들이는 시간을 최소화하는 방식으로 작성된다는 것을 의미하기 때문이다.

-   의도가 모호한 코드
    
    ```java
    // 각 이름이 충분한 정보 제공을 하지 않음
    public List<int[]> getThem() {
        List<int[]> list1 = new ArrayList<int[]>();
        for (int[] x : theList) {
            if (x[0] == 4) {
                list1.add(x);
            }
        }
        return list1;
    }
    ```
    
-   의도가 분명한 코드
    
    ```java
    // 이름이 명확히 변경
    public List<int[]> getFlaggedCells() {
        List<int[]> flaggedCells = new ArrayList<int[]>();
        for (int[] cell : gameBoard) {
            if (cell.isFlagged()) {
            	flaggedCells.add(cell);
            }
        }
        return flaggedCells;
    }
    ```
    

첫 번째 코드는 getThem이 무엇을 하는 함수인지, 변수 list1이 무엇을 담고 있는지 알 수 없다.

하지만 두 번째 코드는 이름만 봐도 getFlaggedCells는 FlaggedCells을 반환하고, FlaggedCells는 flag된 cell들을 담고 있는 것을 알 수 있다.

### 네이밍시 중요한 고려사항

네이밍을 할 때 다음과 같은 질문을 통해 이름을 짓는 것이 필요하다.

-   왜 존재해야 하는가
-   무슨 작업을 하는가
-   어떻게 사용하는가
-   Example
    
    ```java
    public List<Piece> findPiecesByColor(Color color){}
    // 왜 존재해야 하는가 - color에 대해 존재하는 piece들을 알기 위해.
    // 무슨 작업을 하는가 - color에 맞는 piece들을 가져온다.
    // 어떻게 사용하는가 - 체스판에서 흑색(or 백색)의 piece들을 가져와서 점수를 계산.
    ```
    

이름만으로도 언제 이 메서드를 호출해야 하는지 의미를 파악할 수 있도록 구체적으로 작성하도록 해야 한다.

## 메서드 명명 규칙

-   메서드 이름은 lowerCamelCase로 작성한다.
    
    -   메서드의 이름에는 첫 번째 단어를 소문자로 작성하고, 이어지는 단어의 첫 글자를 대문자로 작성하는 소문자 카멜표기법를 사용한다.
-   메서드 이름은 동사/전치사로 시작한다.
    
    -   메서드명은 기본적으로는 동사로 시작한다. 다른 타입으로 전환하는 메서드나 빌더 패턴을 구현한 클래스의 메서드에는 전치사를 쓸 수 있다.
    
    ```java
    // Example
    // 동사
    public void getUserByName(){}
    public void setDisplayName(){}
    public void inputData(String input){}
        
    // 전치사
    public String toString(){}
    public User of(){}
    ```
    
-   JUnit 테스트 메소드 이름에 언더스코어(_)가 표시되어 이름의 논리 컴포넌트를 구분하고 각 컴포넌트는 lowerCamelCase로 작성된다.
    
    ```java
    // Example
    // 1. MethodName_StateUnderTest_ExpectedBehavior (메서드명_테스트상태_기대행위)
    @Test
    void isAdult_AgeLessThan18_False(){}
    
    // 2. MethodName_ExpectedBehavior_StateUnderTest (메서드명_기대행위_테스트상태)
    @Test
    void isAdult_False_AgeLessThan18(){}
    ```
    

## 메서드 이름으로 자주 사용되는 동사

> 동사라도 알면 쓰고 시작을 할 수 있다.(시작이 반이다…) 시간을 조금이라도 단축하고 싶은 마음에 자주 쓰는 동사를 정리해보았다.

-   get/set
    
    -   먼저 getter/setter 관련하여 자바빈 규약이 있다.
    
    ```java
    // 멤버변수마다 별도의 get/set메서드가 존재한다.
    public class Student {
        private String name;
        private int age;
        
        public String getName() {
            return name;
        }
        
        public int getAge() {
            return age;
        }
        
        public String setName(String name) {
            this.name = name;
        }
        
        public int setAge(int age) {
            this.age = age;
        }
    }
    ```
    
    이러한 상황이 아니라면 다음과 같은 말을 기억하면 좋을 것 같다.
    
    > setter 하는 일이 단순하고, 객체 생성 시점에 필요한 모든 값들을 주입하지 않아 개발자의 실수가 발생할 수 있다. 또한, public 으로 공개해놓은 set 메서드는 코드 다른 부분에서 언제 호출되어 값이 바뀔지 알기 힘들다. 고민 없이 자바빈 규약에 따른 getter, setter는 객체지향적인 코드작성에 가장 큰 적이라고 할 수 있다.
    
    > 객체의 데이터에 마음대로 접근할 수 있다면 메소드를 통해 만들어진 데이터는 의미가 없게 되는 문제가 생긴다.
    
    -   되도록이면 상태 데이터를 가지는 객체에서 데이터를 (get)하지 말고 객체에 메시지를 보내는 것을 추천한다.
    
    ```java
    private boolean isMaxPosition(Car car) {
    	return car.getPosition() == maxDistance;
    }
    ```
    
    위와 같이 구현하지 않고 다음과 같이 Car에게 메시지를 보내 구현한다.
    
    ```java
    car.isMaxPosition(maxDistance);
    ```
    
-   init
    
    -   데이터를 초기화하는 메서드 명에 쓰인다.
        
        ```java
        // 만약 User클래스 안에 있다면 User 데이터를 초기화하는 메서드
        public void initData(){}
        ```
        
-   is/has/can
    
    -   위의 3개는 boolean 값을 리턴한다.
    -   is는 맞는지 틀린지 판단하는 메서드 명에 쓰인다.
    
    ```java
    // 숫자인지 판단하는 메서드
    public boolean isNumber(){}
    ```
    
    -   has는 데이터를 가지고 있는지 확인하는 메서드 명에 쓰인다.
    
    ```java
    // Data를 가지고 있는지 확인하는 메서드
    public boolean hasData(){}
    ```
    
    -   can는 할 수 있는지 없는지 확인하는 메서드 명에 쓰인다.
    
    ```java
    // 주문할 수 있는지 없는지 확인하는 메서드
    public boolean canOrder(){}
    ```
    
-   create
    
    > 필자는 팩토리 메서드 패턴 블로그 글에서 많이 보았다.
    
    -   새로운 객체를 만든 후 리턴해주는 메서드 명에 쓰인다.
    
    ```java
    // Board를 만든 후 리턴해주는 메서드
    public Board create(){}
    ```
    
-   find
    
    -   데이터를 찾는 메서드 명에 쓰인다.
    
    ```java
    // number에 해당하는 Element를 찾아 리턴하는 메서드
    public Element findElement(int number){}
    ```
    
-   to
    
    -   해당 객체를 다른 형태의 객체로 변환해주는 메서드 명에 쓰인다.
    
    ```java
    // Ex) String으로 변환하는 메서드
    public String toString(){}
    ```
    
-   A-By-B
    
    -   B를 기준으로 A를 하겠다는 메소드명에 쓰인다.
    
    ```java
    // Ex) Name을 기준으로 User를 get하는 메서드
    public void getUserByName(String name){}
    ```
    

## 참고한 사이트

[자바 명명 규칙](https://m.blog.naver.com/reona7140/221306141987)

[7 Popular Unit Test Naming Conventions](https://dzone.com/articles/7-popular-unit-test-naming)

[Google Java Style Guide](https://google.github.io/styleguide/javaguide.html#s5.3-camel-case)

[캠퍼스 핵데이 Java 코딩 컨벤션](https://naver.github.io/hackday-conventions-java/#method-lower-camelcase)

[우리집앞마당](https://multifrontgarden.tistory.com/207)

[Dev 미티치 블로그](https://mititch.tistory.com/77)


----

# [변수 이름 잘 짓기 (feat. 코드 네이밍 컨벤션)](https://chronic794.blogspot.com/2021/02/blog-post_22.html)

-  [2월 22, 2021](https://chronic794.blogspot.com/2021/02/blog-post_22.html "permanent link")

## 시작하기 전에

## 

이 글의 내용은 [개발자의 글쓰기](https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=209572978)에서 다루고 있고, 내용 중 일부만 발췌하였으니 좀 더 자세한 내용을 알고싶다면 위 책을 보는것을 추천드립니다.

  

## 개발자의 가장 큰 고민은 이름 짓기

## 

아무리 작은 프로그램이나 간단한 애플리케이션이라도 수많은 이름을 지어야 한다. 변수 이름부터 시작해서 함수, 클래스, 파일, 디렉터리, 데이터베이스 칼럼, 심지어 프로젝트 이름까지 정해야한다.

모든 개발자는 자기 코드를 읽는 사람이 주석 없이도 금방 이해하게 코드를 작성하고 싶어 한다.

함수가 어떤 일을 하는지 이름만 보고도 짐작하게 만들고 싶어 한다. 그러면서도 간결하고 명료하며 일관성을 가진 이름을 짓고 싶어한다.

  

하지만 현실은 그렇지 못하다. 이름을 잘못 지어서 코드를 이해하기가 어렵고，자기가 이름을 지어놓고도 나중에는 그 이름이 무엇을 뜻하는지 모를 때도 많다.

코드를 일일이 다시 열어보고 나서야 그때 그 이름을 왜 그렇게 지었는지 떠올린다.

  

이름 짓기가 어렵긴 하지만 잘만 하면 코드를 짜기도 쉽고 이해하기도 쉽다.

다른 개발자와 소통하기도 쉬워지고, 공개할 경우 외부 개발자에게 인정도 받는다. 게다가 요즘같이 애자일이 주목받아서 문서를 최소로 만드는 시대에 문서 대신에 코드로 소통하려면 좋은 이름 짓기는 필수다.

  

하지만 막상 함수 이름을 지으려고 하면 도대체 어디서부터 시작해야 할지 막막할 때가 많다. 게다가 한글이 아닌 영어로 이름을 지어야 하고, 그에 따라 영어 표기법도 고려해야 한다.

다른 개발자가 봤을 때 한 번에 무슨 뜻인지, 무슨 기능을 하는지 알아낼 수 있는 이름이어야 한다. 그러면서도 아주 간결해야한다.

  

인기 있는 자바 소스의 네이밍 비법은 다른 게 아니라 기존 영어 규칙을 지키고 기존 단어를 적절히 조합해서 사용한 것이었다. 그러므로 네이밍의 특징과 규칙만 잘 이해한다면 누구나 쉽게 이름을 지을 수 있을 것이다.

  

우선은 네이밍 컨벤션부터 알아보고, 변수의 이름을 짓는 구체적인 방법을 터득해 보자.

  

코드 네이밍 컨벤션

## 

-   파스칼 표기법으로 클래스 이름 짓기

파스칼 표기법은 모든 단어에서 첫 글자를 대문자로 쓰는 방식이다. 주로 클래스 이름에 사용한다. 그 이유는 클래스가 프로그래밍에서 가장 주요하고 높은 위치에 있고, 고유명사처럼 특정되며, 명사로 되어있기 때문이다. 클래스 이름으로 명사 여러 개를 붙여 쓰는 경우에는 각 명사의 첫 글자를 모두 대문자로 쓴다. 이것은 인터페이스도 마찬가지다.

## 

-   카멜 표기법으로 함수-변수의 이름 짓기

카멜 표기 법은 첫 단어를 빼고 나머지 단어의 첫 번째 글자만 대문자로 쓴다. 주로 함수나 변수에 시용한다. 함수는 동작을 시키는 명령어 개념이므로 첫 단어가 주로 동사다. 변수는 형용사로 시작하는 경우도 많다. 영어 표기 원칙의 기본은 명사가 아닌 경우 첫 글자를 소문자로 시작한다는 것이다. 그래서 함수와 변수는 모두 첫 단어의 첫 글자를 소문자로 쓴다.

## 

-   상수는 모두 대문자로 쓴다

프로그래밍할 때는 소문자를 쓰는 변수와 구별하기 위해 상수를 모두 대문자로 쓰고 언더스코어 (_)로 단어를 연결한다. 상수는 값이 변해서는 안 된다는 점을 강조하고 주의시키기 위해 가독성을 높이는 방법으로 대문자를 선택한 것이다.

하지만 요즘에는 통합개발환경(IDE)이 발전해서 굳이 상수를 모두 대문자로 쓸 필요가 있는지 의문이다. 상수를 대문자로 쓸지 말지는 개인의 자유지만，어느 쪽이든 회사 안에서는 통일하는 것이 좋다.

## 

-   패키지와 모듈은 모두 소문자로 쓴다

패키지와 모듈은 분명히 클래스나 함수보다 더 높은 위치다. 그러므로 패키지 이름과 모듈 이름은 당연히 대문자로 써야 할 것 같다. 하지만 실제로는 소문자로만 쓴다.

  

이것은 패키지와 모듈이 클래스를 모으거나 함수를 담아놓은 통에 불과하기 때문이다. 클래스가 책이라고 하면 패키지는 전집이라고 볼 수 있다. 우리가 인식하고 구별하는 것은 각각의 책이지 전집이 아니다. 전집은 단지 책을 모아놓은 것에 불과하다.

  

물론 실용적인 이유도 있다. 패키지 이름과 클래스 이름을 혼동할 수 있고, 모듈 이름과 함수 이름을 햇갈릴 수 있어서 패키지와 모듈 이름은 모두 소문자로 쓰는 것으로 누군가가 정했고, 그것이 그대로 컨벤션으로 자리 잡았다.  

  

## 네이밍 컨벤션의 결론 - 가독성과 소통이 먼저다

대문자를 쓰든 소문자를 쓰든, 하이픈을 쓰든 언더스코어를 쓰든 중요한 것은 표기법 자체가 아니라 그렇게 쓰는 이유다. 그동안 수많은 개발자가 이렇게 컨벤션을 만든 이유는 가독성과 소통 때문이다. 코드를 읽기 쉽게 만들고 다른 개발자와 소통하기 위해서다. 남들이 으레 그렇게 하니 따라 할 것이 아니라 그렇게 쓰는 이유를 알고 써야 한다.

  

그런데 요즘에는 개발 툴이 워낙 발전해서 굳이 이렇게 대소문자를 가려 쓰지 않아도 색깔로 쉽게 구별할 수 있지만, 가독성이 높다고 소통이 더 잘 되는것은 아니다.

가독성이 높아도 개발자들리 서로 이해하는 바가 다르면 오히려 소통하기가 어려워진다. 소통이 잘 되려면 서로가 같은 컨벤션을 지켜야 한다.

  

따라서 같은 부서의 개발자, 또는 하나의 프로그램과 관련된 개발자들끼리는 코딩하기 전에 기본적인 컨벤션 규칙을 정하는 것이 우선이다. 그래야 가독성과 소통이라는 두 마리 토끼를 동시에 잡을 수 있다.

  

## 개발 시간을 줄여주는 변수 이름 짓기

## 

-   복수형을 나타내는 S를 붙일까 말까?

배열을 복수로 나타내는 방법이 있다. 예를들어 UserName을 복수형으로 UserNames 라고 쓰는 것이다. 변수명에 복수형을 나타내는 -s가 붙어 있기 때문에 쉽게 알아볼 수 있다. 함수명 중간에 사용할 때는 -s가 눈에 잘 띄지 않는다.

그래서 변수명은 그냥 두더라도 함수명에서는 -s 대신 'array'나 'list of'를 쓰는 편이 더 나을 수도 있다. 어떤 것이 편한지는 개인마다 다르겠지만 회사 또는 프로젝트 안에서는 규칙을 하나로 통일해야 할 것이다.

## 

-   약어를 쓰는 것이 좋을까? 안 쓰는 것이 좋을까?

약어를 추천하는 개발자도 있고 절대 쓰지 말라 는 개발자도 있다. 그런데 실제로 코드를 작성하다 보면 약어를 쓰는 것이 편할 때가 많다. 용어 정의서에 약어 설명을 하나 추가하기만 하면 코드를 짤 때 원래 단어를 일일이 쓰지 않아도 된다.

책에서는 서비스 이름이나 패키지 이름，또는 클래스 이름에 약어를 쓰는 것도 그리 나쁘지 않다고 보고있다.

  

약어를 만드는 좋은 방법은 보편성을 기준으로 정하는 것이다. 회사나 업계에서 많이 사용하는 약어라면 코드에 사용하는 것이 좋다. 예를 들어 HTML을 누구도 HyperTextMarkupLanguage라고 말하지 않는다. User Interface는 UI라 쓰고, User Experience는 UX라 쓴다.

  

변수 temp는 원래 temporary다. 하지만 누구도 temporary로 쓰지 않는다. document는 doc으로, parameter는 param으로, argument는 arg로 쓴다.

  

어떤 이름을 약어로 쓰고 싶다면 몇 가지 안을 만들어서 비개발자에게 물어보는 것도 좋다.

## 

-   중요한 단어를 앞에 쓴다

변수 이름을 여러 단어로 조합할 때는 순서를 잘 정해야 한다. 예를 들어 총 방문자 수를 나타내는 변수를 보통 totalVisitor로 그대로 번역해 변수로 사용하곤 한다. 하지만 이 변수를 다시 사용할 때는 total로 검색을 시작하는 경우보다 visitor로 검색을 시작하는 경우가 더 많을 것이다. 따라서 total이라 는 수식어보다는 본래 의미를 뜻하는 visitor를 앞에 쓸 것을 추천한다.

  

[![](https://lh3.googleusercontent.com/-2q84YaaVFLA/YDPaJcOXk6I/AAAAAAAAAag/v3a5-HH8oAU67NshhRD2LsVlfgNqY-K_wCLcBGAsYHQ/s16000/image.png)](https://lh3.googleusercontent.com/-2q84YaaVFLA/YDPaJcOXk6I/AAAAAAAAAag/v3a5-HH8oAU67NshhRD2LsVlfgNqY-K_wCLcBGAsYHQ/image.png)

물론 요즘 개발 도구는 검색할 때 해당 단어가 포함된 클래스나 변수를 다 찾아준다. 그래서 단어를 조합해 이름을 지을 때 순서가 그다지 의미 없을 수도 있다. 다만 중요한 것이 앞에 와야 한다는 기본 원칙은 지키자.

  

## PS. 참고하면 좋은 글

## 

깃허브의 인기 자바 소스를 분석해서 클래스, 함수, 변수 이름의 명명 특징을 연구한 블로그 글 "오픈소스의 네이밍 특징들([https://brunch.co.kr/@goodvc78/12](https://brunch.co.kr/@goodvc78/12))"은 몇 가지 중요한 네이밍 규칙을 데이터로 증명했다.

## Reference

-   [개발자의 글쓰기](https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=209572978)


----

[오픈소스 네이밍의 특징들](https://brunch.co.kr/@goodvc78/12)

종종 보게 된 페이스북 피드글 중에서...

프로그래머 4,522명이 대답했습니다.

![](//t1.daumcdn.net/thumb/R1280x0/?fname=http://t1.daumcdn.net/brunch/service/user/Kvs/image/siU3QYhbSYNGg566rxyRF_fos60.png)

네이밍(이름 짓기)은 나에게 많은 고민과 선택을 하게 만든다.

대충 지은 클래스 네이밍 하나 때문에 코드가 걸레가 되기도 하고,

잘 조합된 네이밍 규칙 하나로 소스가 구조적, 기능적으로 술~술~ 잘 풀리기도 한다.

그래서 이 중요한 네이밍에 대하여 알아봤습니다!!

> 참고로 아래 분석을 좀 더 진행하고자 하시는 분은 분석의 전체 과정을 담은 [https://github.com/goodvc78/naming-feature-analysis](https://github.com/goodvc78/naming-feature-analysis) 저장소의 소스를 다운받아서 진행하시면 됩니다.

> 오픈소스의 네이밍 특징들

  

우선, [Github Most Starred Java](http://github-rank.com/star?language=Java)에서 많은 이들이 알만한 소스 20개 선별하여 Clone 받고,

![](//t1.daumcdn.net/thumb/R1280x0/?fname=http://t1.daumcdn.net/brunch/service/user/Kvs/image/J0NaCc6w0vS3NdDpbkZaDFaHcLk.png)

Clone 받은 소스의 총 52,887개 Java파일에서 변수/함수/클래스 네이밍을 추출하였다.

![](//t1.daumcdn.net/thumb/R1280x0/?fname=http://t1.daumcdn.net/brunch/service/user/Kvs/image/MJSub880rRzg86sMtK3mS3gO9So.png)저장소별 Java 파일수

  

----------

  

**Java 소스코드에서 네이밍 추출**

Regular Expression을 적절히 사용하여 주석을 제거하고,

Line단위로 변수/함수/클래스 네임을 인식할 수 있는 심플한 패턴만 만들어서 네이밍을 추출합니다.

Java 주석 제거 : 싱글 라인(//), 멀티라인 패턴(/* */) 찾아서 제거  

![](//t1.daumcdn.net/thumb/R1280x0/?fname=http://t1.daumcdn.net/brunch/service/user/Kvs/image/dGWnB6-eX0tFpjrijQTPHS0VApw.png)

변수 이름 추출 : 변수는 변할 수 있는 값이기 때문에 equal(=) 연산자의 left token을 변수 인식함

![](//t1.daumcdn.net/thumb/R1280x0/?fname=http://t1.daumcdn.net/brunch/service/user/Kvs/image/ss-a8C8UpqTGbmTGbBAu_DOoZ2U.png)

함수 이름 추출 : 단순히 '('로 split을 해서 left token이 함수가 될 수 있는 문자셋으로 구성된 것을 찾음

--> 이 패턴은 함수와 클래스가 명확히 분리되지 않아 클래스 이름도 종종 포함된다.

![](//t1.daumcdn.net/thumb/R1280x0/?fname=http://t1.daumcdn.net/brunch/service/user/Kvs/image/fREH1Vd9JuZu-YuMOXfW4m9HrSs.png)

클래스 이름 추출 : class 단어가 오고, 공백 그리고 클래스 이름으로 허용되는 문자셋으로만 구성된 것 찾음.

![](//t1.daumcdn.net/thumb/R1280x0/?fname=http://t1.daumcdn.net/brunch/service/user/Kvs/image/mK_hy4sG0ouCaCF5iHpmWHQ5o8s.png)

추출된 네이밍에서 Java 언어의 예약어 및 'test'를 포함하는 네이밍은 제거

> abstract default package synchronized boolean do if private this break double implements protected throw byte else import public throws switch enum instanceof return try catch extends int short char final interface static void class finally long strictfp volatile float native super while continue for new case goto null transient const operator future generic ineer outer rest var test

이렇게 하면 100% 정확하지는 않지만 데이터 분석에 괜춘하게 추출됩니다.  

**조합된 네이밍 단어를 Tokenizing**

> 일반적으로 클래스/함수/변수 네이밍은 [Java Naming rule 인](http://%20https//en.wikipedia.org/wiki/Naming_convention_(programming)#Java) Camel Case를 기준으로 UpperCamelCase, lowerCamelCase, lower_delimiter_case, UPPER_DELIMITER_CASE 방식으로 조합되었기 때문에 이 기준으로 단어를 분리한다.  
> "parseDBMXMLFromIPAddress" -> ['parse', 'DBMXML', 'From', 'IP', 'Address']

![](//t1.daumcdn.net/thumb/R1280x0/?fname=http://t1.daumcdn.net/brunch/service/user/Kvs/image/fzZojRn1kaSoSYAW6_9v40pWwJ4.png)Java Naming Rules

**Tokenize 된 단어의 품사 Tagging**

> 단어의 연결 구조를 분석하기 위해 형태소 분석기인 [NLTK(Natural Language Toolkit)](http://www.nltk.org/)로 아래 예시와 같이 품사 Tagging을 합니다.  
> [parse, DBMXML, From, IP, Address]  
> -> [parse[NN], 'dbmxml[NN], from[IN], ip[NN], address[NN]]  

**소스로부터 추출한 네이밍 데이터 셋**

> 네이밍의 특징들을 찾아내기 위한 기본 데이터 셋을 만듭니다.  
> . 네임밍 데이터셋  
> . 품사가 Tagging 된 데이터셋

![](//t1.daumcdn.net/thumb/R1280x0/?fname=http://t1.daumcdn.net/brunch/service/user/Kvs/image/2jZEBgxm5y8SnHeYLgBamHmdYBA.png)

![](//t1.daumcdn.net/thumb/R1280x0/?fname=http://t1.daumcdn.net/brunch/service/user/Kvs/image/ttJLWXV3GYkn9r2YMJKbMKGn7ck.png)

----------

이제부터 좋은 오픈 소스는 어떤 네이밍 특징을 가지고 있는지 탐색해 보도록 하겠습니다.  

**Java 네이밍 rule을 잘 지키는 클래스, 함수, 변수**

> 네임들의 출현 빈도 기준으로 된 WordCloud 결과를 통해 대략적으로 판단합니다

> 클래스는 대문자로 시작하는 UpperCamelCase  
> 함수는 소문자로 시작하는 lowerCamelCase  
> 변수는 소문자로 시작하는 lowerCamelCase  
> 그리고 상수는 대문자와 '_'분리하는 UPPER_DELIMITOR_CASE

클래스 네임 Word Cloud

대문자로 시작하는 UpperCamelCase를 사용하며, 명사 위주의 단어들이 많이 보인다.

  

![](//t1.daumcdn.net/thumb/R1280x0/?fname=http://t1.daumcdn.net/brunch/service/user/Kvs/image/ngDBFglvvC-PWFd3vyXPpcr-8kU.png)출현 빈도 기준 클래스 네임 WordCloud

함수 네임 WordCloud

소문자로 시작하는 lowerCamelCase 형태의 구성으로 동사도 많이 보이는듯함.

예상대로 명확히 분류되지 않아 클래스 명도 종종 포함되어 있음이 확인됨.

![](//t1.daumcdn.net/thumb/R1280x0/?fname=http://t1.daumcdn.net/brunch/service/user/Kvs/image/Ou28e9fr3Qj7BGWSWtwpcDwmoMU.png)출현빈도기준 함수명 Word Cloud

변수 네임 WordCloud

단어 하나로 많이 표현되고,

가장 많이 쓰는 'i' 그리고 어디에서 있어야 할 'LOG' 가 떡하니 중앙에 자리 잡고 있네요.

![](//t1.daumcdn.net/thumb/R1280x0/?fname=http://t1.daumcdn.net/brunch/service/user/Kvs/image/dzkw3V8TAj1kUp1CDrim61Fl5YQ.png)출현 빈도 기준 변수 Word Cloud

  

**유니크한 네이밍 비율은 : 변수=함수> 클래스**

변수의 네이밍 수가 가장 많다고 생각했는데, 예상외로 함수 네이밍수와 비등하게 많음.

![](//t1.daumcdn.net/thumb/R1280x0/?fname=http://t1.daumcdn.net/brunch/service/user/Kvs/image/2CslCmcTzo7Ig4ismMfwzlOT4bU.png)

**네이밍 된 평균 글자 수는 16자 : 클래스(20자)>함수(18자)>>변수(13자)**

네이밍 글자 수는 평균 16자로 생각보다 길게 쓰는 듯했다. 그리고 클래스> 함수>>변수 순으로 네이밍의 글자 수가 달랐는데, 이는 기능이 많고, 스코프를 넓게 가져가는 네이밍 타입의 특성이 적절히 반영된 결과가 아닌가 싶다.

네임들의 글자 수별 분포는 치우침이 없이 아주 아름답게(^^) 정규분포를 잘 따르는 듯하다. 데이터를 다룰 때 이런 분포를 찾아내면 기분이 좋다! 너무 조으다!!!

  

![](//t1.daumcdn.net/thumb/R1280x0/?fname=http://t1.daumcdn.net/brunch/service/user/Kvs/image/7g_c6t2wMp85V6JojTYq0Idbdhw.png)

참고로, Topic(저장소) 별 글자 수 분포

![](//t1.daumcdn.net/thumb/R1280x0/?fname=http://t1.daumcdn.net/brunch/service/user/Kvs/image/Oo7LO6AiFkwoP0DPbLp5qmxY4wM.png)

**네이밍은 평균 3개 단어로 조합됨**

> 3개 단어의 조합으로 네이밍을 하되, 변수는 짧게 함수와 클래스는 조금 더 길게 네이밍 됩니다..

> 클래스 네임 : 3.18 단어  
> 함수 네임 : 3.36 단어  
> 변수 네임 : 2.57 단어

  

**네이밍의 품사 분포**

> 많이 사용하는 품사는 명사>>>형용사> 동사입니다.  
> 특히 함수는 동작을 설명하는 동사가 많이 포함된 것이 특징이다.

![](//t1.daumcdn.net/thumb/R1280x0/?fname=http://t1.daumcdn.net/brunch/service/user/Kvs/image/V8cy9d6LNrKFv3eFMy8map1vwd0.png)

  

**네이밍의 단어 연결 구조 : [명사|동사|형용사] + 명사 + 명사 +...**

> 처음 단어만 목적에 맞게 품사가 선택되고 그다음 단어부터는 대부분이 명사 연속으로 구성된다.

![](//t1.daumcdn.net/thumb/R1280x0/?fname=http://t1.daumcdn.net/brunch/service/user/Kvs/image/pCJCev000zxvnpWUtszwQ6RoYdE.png)

  

클래스는 대부분이 명사와 형용사(실제로 명사 잘못 tagging 된 경우가 많음) 조합이고,

함수는 첫 단어에 동사, 형용사가 많다.

그리고 변수는 상태나 값을 가지기 때문에 시제와 단/복수의 형태가 적절히 사용됨이 보인다.

![](//t1.daumcdn.net/thumb/R1280x0/?fname=http://t1.daumcdn.net/brunch/service/user/Kvs/image/Elm-vqp3F1XrNJQVe356WsGHbyI.png)

  
  

**품사별 많이 사용된 단어는?**

> 네이밍 단어 조합 분석을 위한 NLTK의 품사 Tagging의 정확도는 만족스럽지 못하다.  
> ( NLTK는 일반 문장 규칙을 기반으로 구현되었기 네이밍 단어 조합에서는 정확도가 떨어짐이 당연해 보인다.)

클래스 단어의 품사별 사용 단어

> 명사 위주의 단어와 함께 design pattern과 관련된 단어들의 많은 사용이 보여진다.

![](//t1.daumcdn.net/thumb/R1280x0/?fname=http://t1.daumcdn.net/brunch/service/user/Kvs/image/SKUpZUgOhrV_wIe-p_pH4vimJnU.png)

함수 단어의 품사별 사용 단어

> get, set 단어의 사용빈도와 더불어 동사가 적극적으로 사용됨이 보인다.

![](//t1.daumcdn.net/thumb/R1280x0/?fname=http://t1.daumcdn.net/brunch/service/user/Kvs/image/-drQ-XSJcHNDxX0SxsrmiyK2IwI.png)

변수의 품사별 사용 단어

![](//t1.daumcdn.net/thumb/R1280x0/?fname=http://t1.daumcdn.net/brunch/service/user/Kvs/image/2BPDLBx7NJEKGdIQ4vMGCsPYJK0.png)

  

**소스별 Topic 분석해 보기**

네이밍의 단어들은 그 소스를 가장 잘 설명하는 용어일 것이다. 그래서 이 단어들의 Topic을 잘 추출해 보면 그 소스가 중요시하는 부분이나 특성을 잘 파악할 수 있을 것 같아 Topic 모델링을 해 보았다. Topic 모델링 방법 중 가장 많이 알려지고 간단한 TF-IDF를 사용하였다.

  

먼저 단순히 단어 빈도(Term Frequency) 기준으로는 Hadoop 소스(좌)와 ElasticSearch 소스(우)의 확인해 보면 Topic이 제대로 나타나지가 않았다.

![](//t1.daumcdn.net/thumb/R1280x0/?fname=http://t1.daumcdn.net/brunch/service/user/Kvs/image/nP0u-tHeXff4bCiYfkN8YOsv-3E.png)

![](//t1.daumcdn.net/thumb/R1280x0/?fname=http://t1.daumcdn.net/brunch/service/user/Kvs/image/8fNxfK3Z8EdeFShexEY_N5zgt9s.png)

  

그래서 단어 빈도(TF)에 문서 출현 빈도의 역수(IDF)를 Weight로 적용하는 TF-IDF로 Topic 모델링해 보면(아래 WordCloud), 고급진 LSA나 LDA 못지않게 (생각보다) 특징점이 잘 뽑여 나오는듯하다. (예상보다 예쁘게 잘 나와서 기분이 좋다.)  

Elastic Search 소스의 Topic

> 아래 Elastic Search 소스의 Topic을 보면 는 shard, cluster, routing 등 분산 처리 기능의 위해 구현체가 많이 들어 있는 듯 보인다.

![](//t1.daumcdn.net/thumb/R1280x0/?fname=http://t1.daumcdn.net/brunch/service/user/Kvs/image/b6Ccd8o3I11D71NC8dIV7f1wquA.png)

Hadoop 소스의 Topic

> Hadoop 소스는 timeline, job, yarn, dfs, conf 등 분산 저장과 처리를 위한 Job 스케줄링과 자원 관리에 에 많은 신경을 쓴 소스로 보인다.

![](//t1.daumcdn.net/thumb/R1280x0/?fname=http://t1.daumcdn.net/brunch/service/user/Kvs/image/1mptHlfVuzn25WeXMyZVEBWx9Gk.png)

**각 소스의 Topic 들**

> 이렇게 Topic을 보고 있으니 소스를 분석을 시작할 때 주요 Topic 중 모르는 용어는 찾아 보고 시작하면 소스 분석이 훨 수월해질 것 같다는 생각도 든다.

  

![](//t1.daumcdn.net/thumb/R1280x0/?fname=http://t1.daumcdn.net/brunch/service/user/Kvs/image/yXUagrm-Ud_wgQ2OvMkvN3l22pc.png)

![](//t1.daumcdn.net/thumb/R1280x0/?fname=http://t1.daumcdn.net/brunch/service/user/Kvs/image/wbm-jpilJboY4aeh0GY04mLlThQ.png)

![](//t1.daumcdn.net/thumb/R1280x0/?fname=http://t1.daumcdn.net/brunch/service/user/Kvs/image/ZkPP6Wd3rJBkPybFnWeFYC3I7Kk.png)

![](//t1.daumcdn.net/thumb/R1280x0/?fname=http://t1.daumcdn.net/brunch/service/user/Kvs/image/G1a9FaYejUUIQUMg_8BZTytkrYI.png)

![](//t1.daumcdn.net/thumb/R1280x0/?fname=http://t1.daumcdn.net/brunch/service/user/Kvs/image/chno1CsS-nCiSUw2QE86rMH4iHc.png)

![](//t1.daumcdn.net/thumb/R1280x0/?fname=http://t1.daumcdn.net/brunch/service/user/Kvs/image/ZIbmZzGHueaCTZMy0O7ejLYo2lc.png)

![](//t1.daumcdn.net/thumb/R1280x0/?fname=http://t1.daumcdn.net/brunch/service/user/Kvs/image/ahRfxNp_NrBEGN5lZ1B0agw17RA.png)

![](//t1.daumcdn.net/thumb/R1280x0/?fname=http://t1.daumcdn.net/brunch/service/user/Kvs/image/AyGwisRcwpyO6SVJ1srlRt8xcVc.png)

![](//t1.daumcdn.net/thumb/R1280x0/?fname=http://t1.daumcdn.net/brunch/service/user/Kvs/image/wmBkLbN2niEpAEIVSXMdBc7-4tQ.png)

![](//t1.daumcdn.net/thumb/R1280x0/?fname=http://t1.daumcdn.net/brunch/service/user/Kvs/image/xmKb3ymnnA7Y2bSgdspDqt0cH1w.png)

![](//t1.daumcdn.net/thumb/R1280x0/?fname=http://t1.daumcdn.net/brunch/service/user/Kvs/image/2D-Y21K4r-n14HXNlPSk4wW7lmU.png)

![](//t1.daumcdn.net/thumb/R1280x0/?fname=http://t1.daumcdn.net/brunch/service/user/Kvs/image/K_3Khn5Mg-uhIdm3D1l3Pq-Q7gk.png)

![](//t1.daumcdn.net/thumb/R1280x0/?fname=http://t1.daumcdn.net/brunch/service/user/Kvs/image/GeFnF9OMOnCb_TV5P6cQUuxyckI.png)

![](//t1.daumcdn.net/thumb/R1280x0/?fname=http://t1.daumcdn.net/brunch/service/user/Kvs/image/LnOYHQTIPaKCtTS48milYxaRd4M.png)

![](//t1.daumcdn.net/thumb/R1280x0/?fname=http://t1.daumcdn.net/brunch/service/user/Kvs/image/qIXYRbnaI-qEmRYNhRGE6IHynDE.png)

![](//t1.daumcdn.net/thumb/R1280x0/?fname=http://t1.daumcdn.net/brunch/service/user/Kvs/image/ArP-aqrb-jS9hkZ3udHc4jY3-qg.png)

![](//t1.daumcdn.net/thumb/R1280x0/?fname=http://t1.daumcdn.net/brunch/service/user/Kvs/image/pD9sb_8zQ_SDGTbZgEYztI8aPpo.png)

![](//t1.daumcdn.net/thumb/R1280x0/?fname=http://t1.daumcdn.net/brunch/service/user/Kvs/image/OBYvMYe90Q8hCMuYfG418U6MFts.png)

  

**어떤 소스들이 유사할까?**

TF-IDF로 추출된 김에, Topic의 BOW(Bag of Words) Vector로 유사한 소스끼리 군집화 해 봤다.

군집화된 결과도 그럴듯하게 좋았다. 단순히 소스의 커미터끼리 묶인 것이 아닌, 기능이나 목적이 비슷한 계열의 소스끼리 연관되어 군집화 됨을 볼 수 있었다.

가장 유사도가 높은 소스는 목적이 유사한 안드로이드의 이미지 처리 라이브러리인 fresco와 picasso 였다.  

![](//t1.daumcdn.net/thumb/R1280x0/?fname=http://t1.daumcdn.net/brunch/service/user/Kvs/image/fDs8T7bz6uUj6G_8hv3aJRBC2l8.png)

----------

  

### **좋은 소스의 네이밍 규칙들을 요약해 보면**

1. Java Naming Rule을 철저히 준수한다.

- 클래스는 UpperCamelCase,

함수는 lowerCamelCase,

변수는 lowerCamelCase,

상수는 UPPER_DELIMITOR_CASE

2. 네이밍은 보통 16자, 3 단어로 적절히 길게 짓는다.

- 변수는 조금 짧게, 함수/클래스는 조금 길게

3. 네이밍 단어의 조합은 [명사|형용사|동사] + [명사] + [명사]...로 구성

4. 네이밍에 사용된 단어는 소스를 잘 설명한다.

5. 내가 작성할 소스와 비슷한 소스의 Topic 단어를 사전에 알아두면 좋다.

  

### **정리하면서**

이번 네이밍 데이터 탐색의 목적은 개인적으로 코딩 시 (좋고 나쁨을 떠나) 네이밍 일관성을 위해

명시적 네이밍 규칙을 찾는 것이 목적인데 나름 적절한 결과를 얻은 듯하다.

그리고 네이밍 데이터를 가만히 보니 네이밍 규칙을 넘어 네이밍 하고자 하는 단어만 입력하면

자동완성처럼 적절한 네임을 추천하는 네이밍 추천 시스템을 만들어도 좋을 듯하다.

(시간 나면 만들어 봐야겠다.)

  

참고 자료  

github 인기 저장소 : [http://github-rank.com/star?language=Java](http://github-rank.com/star?language=Java)

주석 찾기 패턴 : [http://blog.ostermiller.org/find-comment](http://blog.ostermiller.org/find-comment)

Java Naming Convention : [https://en.wikipedia.org/wiki/Naming_convention_(programming)#Java](https://en.wikipedia.org/wiki/Naming_convention_(programming)#Java)

코드 하이라이트: [http://colorscripter.com/](http://colorscripter.com/)

형태소 분석기 : [http://www.nltk.org/](http://www.nltk.org/)

Gensim의 TF-IDF:[https://radimrehurek.com/gensim/models/tfidfmodel.html](https://radimrehurek.com/gensim/models/tfidfmodel.html)

Python Word Cloud Package :  [https://github.com/amueller/word_cloud](https://github.com/amueller/word_cloud)


----

# [개발자의 글쓰기](https://honggaruy.github.io/wiki/book-developer-writing/)


[created: 2020.11.26](https://github.com/honggaruy/honggaruy.github.io/blame/master/_wiki/book-developer-writing.md)

[updated: 2021.03.14](https://github.com/honggaruy/honggaruy.github.io/blame/master/_wiki/book-developer-writing.md)


# 개요

![개발자의 글쓰기 표지](http://image.kyobobook.co.kr/images/book/xlarge/744/x9791158391744.jpg)

지은이: 김철수  
책제목: 개발자의 글쓰기  
부제: 변수 네이밍부터 릴리스 노트, 장애 보고서, 기술 블로그까지 프로그래머의 글쓰기 고민 끝!  
  
펴낸곳: 위키북스  
초판발행: 2019년 10월 04일  
ISBN: 979-11-5839-174-4 (13000)  
값: 18,000원

# 프롤로그 : 개발자의 글쓰기는 달라야 한다

### 개발자 글쓰기의 특징: 정확성, 간결성, 가독성

-   개발자 글쓰기의 3원칙 : 정확성, 간결성, 가독성
-   3가지 원칙이 서로 대치(반비례?) 관계에 있다는 것이 문제
    -   예) 정확성을 높이면 간결성과 가독성이 낮아짐

### 개발자의 글쓰기

-   적당한 정도의 정확성, 간결성, 가독성을 유지하는 방법을 배워야 함
-   이것이 저자가 책을 쓴 이유임

# 1장 : 개발자가 알아야 할 글쓰기 기본

## 01_ 문장과 단락을 구조화하는 법

### 문장을 구조화하는 법

-   시간과 수고가 많이드는 문장
    
    > 색상 RGB 값을 각각 사용하기 때문에 입력 데이터는 3차원 벡터다.
    
-   주어(“입력 데이터”)를 문장 처음으로..
    
    > 입력 데이터는 색상 RGB 값을 각각 사용하기 때문에 3차원 벡터다.
    
-   인과관계의 복문이므로 두문장으로 나누면..
    
    > 입력 데이터는 색상 RGB 값을 각각 사용한다. 그래서 입력 데이터는 3차원 벡터다.
    
-   본인이 잘아는 내용(혹은 말하고자 하는 결론) 먼저쓰고 ..
    
    > 입력 데이터는 3차원 벡터다.
    
-   .. 부가 설명을 붙인다.
    
    > [입력 데이터]  
    > 입력 데이터는 3차원 벡터다. 색상 RGB 값을 각각 사용하기 때문이다.
    
-   문장을 쉽게 쓰려면…
    -   간단한 문장 구조로 핵심만 말한 뒤,
    -   필요에 따라 부가 설명을 한다.
-   위 작업의 성과
    -   첫문장과 비교하여  `가독성`을 확보했다.
    -   첫문장의 주어를 소제목으로 만들어 자연스럽게 문단을 구성했다.

### 서술식, 개조식, 도식의 차이

-   세가지 방법
    1.  서술식
        -   ‘~다’로 끝나는 완전한 문장
        -   설명문이나 논증, 소설, 신문, 개발 가이드 문서에서 주로 쓰임
        -   줄거리가 있는 설명, 이야기에 어울림
    2.  개조식
        -   종결어미 ‘~다’ 대신 명사 혹은 용언의 명사항 ‘~했음’으로 끝남
        -   신문의 헤드라인, 릴리스 문서, 장애 보고서
        -   항목과 내용이 반복될 때
    3.  도식
        -   그림이나 서식을 사용
        -   행, 열로 이뤄진 표도 도식에 포함됨
        -   각 항목이나 사항의 관계를 명확히 규정
-   (내 생각) 본 위키를 보면 알겠지만 개조식으로 모두 커버할 수 있다고 본다.
    -   개조식은 가독성 측면에서 원탑임
    -   설명문도 개조식을 잘만쓰면 훨씬 낫고..
    -   도식이 가독성이 좋은 경우도 있지만 번거로움.. 정말 필요할 때 가끔씩 써 준다.

### 개조식 서술 방식과 글머리 기호 - 읽음

### 단락을 구조화하는 위계 - 읽음

-   개발자들은 제발 일반 문서에서 space로 들여쓰기 하지마라 … 이건 코드가 아님

## 02_ 쉽게 쓰는 띄어쓰기와 문장 부호

### 가장 쉬운 띄어쓰기 원칙

-   다음 한 문장의 법칙만 지키면 된다
    
    > 조사, 순서, 숫자, 하다, 기호만 붙이고 나머지는 띄어 쓴다.
    
-   함수를 선언할 때 함수 이름 끝에 괄호를 쓰고 그안에 인수를 쓰는데, 이때도 붙여 쓴다.
    
    ```
    // bad example
    wordSpacing( arg1, arg2 )
    // good example
    wordSpacing(arg1, arg2)
    
    ```
    
-   (내 생각) 근데 for 문에서  `for(i=0; ...)`  이런식으로 붙여 쓰면 답답하던디…
    -   아직 책을 다 안 읽었으니 섯불리 판단하지 말자

### 오해하기 쉬운 문장 부호(큰따옴표, 작은따옴표)

-   C에서 작은따옴표는 단일 문자에, 큰따옴표는 문자열에 사용
-   SQL은 쿼리문 안에서 작은따옴표를 사용
    -   다른 언어에서 쿼리문 인용하는 경우가 많은데 따옴표 중복을 막기 위함
-   Javascript도 주로 작은따옴표 사용
    -   HTML이 주로 큰따옴표를 사용하여 중복을 막기 위함
    -   실제로는 번갈아 씀
-   한글의 규정도 있고..
-   비즈니스 문서에는 또다른 규칙이 있음

## 03_ 영어 단어 선택과 외래어 표기법

### **비슷한 듯 다른 듯, 단어 선택**

-   개발 네이밍시 반대 단어를 써야할 때
    -   예를 들면 HTML에서 show 했으면 hide 도 해야 한다
    -   이 때 hide 대신 invisible을 쓰면 안됨
    -   invisible의 반대말은 visible이기 때문 (사용자가 예상할 수 있어야 함)
-   반대말 예제
    -   head의 반대말? tail, toe, foot , but HTML에서는  `footer`
    -   미만은 under, 초과는 over
    -   이하는 or under, 이상은 and over
    -   before ↔ after, open ⇔ cloase, input ⇔ output, import ⇔ export
-   `중단`  의미 영단어 (유의어 예제)
    -   stop, finish, pause, suspend, hold
    -   stop, pause는 잠시 중단, 언제든 다시 시작할 수 있을 때 ( 중단 강도: stop > pause )
    -   end, finish는 완전히 중단되어 재시작할 가능성이 없을 때 ( 중단 강도: end < finish )
    -   suspend는 다음 단계의 시작을 중단한 것, hold는 어떤 의도가 있어 중단한 것
        
        ```
        stopUserRegister(); // 사용자 등록은 잠시 중단한다. 
        // 재개하려면 startuserRegister()나 restartuserRegister()를 사용
        
        ```
        
-   동사 get은 어떤 값을 돌려받아 반환하는 함수에 사용
    -   비슷한 의미인 return은 함수 이름에 잘 쓰지 않음 - 함수내에서 제어에 필요한 keyword라서..
    -   또한, return의 주체는 객체
        -   함수 이름에 return을 쓴다면 자기가 자기에게 돌려준다는 이상한 의미..
    -   get의 유의어 사용방법
        -   retrieve( 개 종류 리트리버의 그것..) - retrieve는 검색해서 가져온다는 뜻 ( 검색에 비중이 있을 때 쓰면 좋음)
        -   aquire는 독점한다는 뜻 - 다른 함수가 결과를 가져가지 못하게 독점하고자 할 때는 acquire
        -   fetch는 현재 값을 가리키는 포인터가 다음 값으로 이동한 것을 가져온다는 뜻
-   set 은 값을 변경하거나 설정하는 함수
    -   (내생각) get과 set은 세트로 많이 씀
    -   register는 이미 정해진 틀에 값을 집어넣는 것
    -   create는 정해진 틀이 없을때 틀을 만드는 작업
-   수정을 나타내는 change, modify, revise는 서로 의도가 다른말
    -   change는 내용을 단순히 바꾸는 것
    -   modify는 잘못된 것을 바로잡을 때
    -   revise는 기존에 없던 새로운 정보나 아이디어를 덧붙여 보강할 때
-   parameter는 매개변수, 함수에 정의한 변수
    -   argument는 전달 인자로, 함수를 호출할 때 전달되는 값
-   attribute는 HTML에서 태그 안에 속성을 넣을 때 사용되는 요소
    -   하지만 이 요소를 HTML DOM에서 가리킬 때는 property라고 함
    -   attribute와 property는 언어마다 조금씩 다르게 해석함
-   must와 should는  `~해야 한다`로 똑같이 번역하지만, 스펙, 요구사항에서 전혀 다른 뜻으로 사용됨
    -   must는 필수 요구 사항, must not은 일어나서는 안되는 일
    -   should는 권고 또는 권장 사항, should not은 하지않는 것이 더 좋다는 정도
-   정확한 단어를 쓰는 것도 좋지만, 일관성과 개연성이 더 중요함.

### 외산 제품 표기와 외래어 표기법

-   widows 표기 사례
    -   MS가 첨에  `윈도우95`로 표기
    -   1995년 9월 5일(?)에 국립 국어원이 Windows 95를 심의할 때..
        -   [`윈도95`로 표기해야 한다고 결정](https://www.korean.go.kr/front/onlineQna/onlineQnaView.do?mn_id=216&qna_seq=63425)
        -   그 후 언론사들이 윈도95로 표기하면서 혼란이 시작
    -   표준과 실제의 차이
        -   표준 : 외래어 표기법 ~ ow[ou] 발음은 ‘오’로 적는다
        -   실제 :  [구글 트렌드로 ‘윈도10’과 ‘윈도우10’의 검색 수 비교](https://trends.google.co.kr/trends/explore?geo=KR&q=%EC%9C%88%EB%8F%8410,%EC%9C%88%EB%8F%84%EC%9A%B010)
        -   [위키백과도 윈도우10으로 표기](https://ko.wikipedia.org/wiki/%EC%9C%88%EB%8F%84%EC%9A%B0_10)
-   release note에서 표기법에 따라 ‘릴리스’로 써야 함
    -   [위키백과도 릴리스 노트로 표기](https://ko.wikipedia.org/wiki/%EB%A6%B4%EB%A6%AC%EC%8A%A4_%EB%85%B8%ED%8A%B8)
    -   하지만, 개발자들이 대화할 때는 대부분 릴리즈로 발음
    -   비슷한 예, basic을 ‘베이식’이라고 안하고 ‘베이직’이라고 함
    -   (내생각)  `ㅅ+ 모음`은 왠지 바람빠지는 기분으로 입에 찰지게 붙지 않음.  `ㅈ+모음`이 입에 짝짝 붙는 기분..
-   외래어 표기법 제1조 제5항
    
    > 이미 굳어진 외래어는 관용을 존중하되, 그 범위와 용례는 따로 정한다
    
    -   외래어 표기법은 표준보다 일관성이 중요
    -   [한국에서 파이썬이 파이썬이 된 사연, 장혜식님 블로그](http://openlook.org/wp/why-python-is-called-python-in-korea/)
    -   [국립국어원 외래어 표기 용례 찾기](https://kornorms.korean.go.kr/example/exampleList.do)
    -   [한글라이즈, 무료 외래어 변환 사이트](https://hangulize.org/)

# 2장 : 개발 시간을 줄여주는 이름 짓기와 주석 쓰기

## 01_ 네이밍 컨벤션, 이유를 알고 쓰자

### 개발자의 가장 큰 고민은 이름 짓기

### 이름 짓기는 창조가 아니라 조합

-   이름 짓기의 착각 : 무에서 유를 창조하는 것? 그건 아님
    -   라이브러리 가져다 쓰듯이 .. 기존것을 차용하고 달라지는 부분만 만들면 됨.
    -   한국이름의 예: 라이브러리: 성씨, 돌림자 만드는 것: 나머지 한자
-   [오픈소스의 네이밍 특징들, Java 언어 사례](https://brunch.co.kr/@goodvc78/12)
    -   자바 네이밍 컨벤션을 철저하게 준수
    -   네이밍은 보통 16글자, 3단어의 조합
    -   품사는 주로 명사, 동사, 형용사의 조합

## 02_ 변수 이름을 잘 짓는 법

### 코드의 네이밍 컨벤션은 영어 표기법을 상속받았다

-   네이밍 컨벤션은 기본적으로 영어 표기법을 준수
-   파스칼 표기법, 카멜 표기법은  [영어의 대문자 표기 원칙, Capitalization](https://en.wikipedia.org/wiki/Capitalization)을 상속 받은 것
    -   위키피디아 에서는  [Camel case](https://en.wikipedia.org/wiki/Camel_case)가 표준, pascal case도 이쪽으로 redirect 됨
-   영어 대문자 표기 원칙의 특성
    1.  중요, 큰 것, 특정한 것, 제목 명사는 첫 글자를 대문자로
    2.  그런 명사들이 이어질 때 모두 첫 글자를 대문자로
    3.  명사, 관사가 아닌 동사, 형용사는 소문자로

### 파스칼 표기법으로 클래스 이름 짓기

-   모든 단어에서 첫글자를 대문자 쓴다
    -   주로 클래스 이름 - 클래스가 프로그램에서 가장 높은 위치
    -   클래스 이름으로 명사 여러 개를 붙여 쓰는 경우 - 각 명사를 모두 대문자로 씀
        
        ```
        interface Menu
        class CoffeeMenu implements Menu
        
        ```
        

### 카멜 표기법으로 함수◦변수의 이름 짓기

-   카멜 표기법은 첫 단어를 빼고 나머지 단어의 첫 번째 글자만 대문자로 쓴다
    -   주로 함수나 변수에 사용
    -   함수는 동작에 관계되므로 첫 단어가 주로 동사
    -   변수는 형용사로 시작되는 경우도 많음
    -   영어 표기법과 연결시켜보면 당연

### 상수는 모두 대문자로 쓴다 (내생각 - 꼭 그럴 필요가 있을까?)

-   이부분은 영어 표기 원칙과는 다름
    -   원주율 파이 : Pi
    -   그리스어 알파벳 : 𝝅 (대문자: 𝜫, 대문자는 상수표기로 사용하지 않음)
-   변수와 구분하기 위해 모두 대문자를 쓰고 _(언더스코어)로 연결한다
-   **요즘 통합개발환경의 발달로 굳이 구분을 위해 대문자로 써야할지 필요성에 의문**
-   (내생각) 클래스로 다음과 같이 지정하고 사용하는 것이 좋음. 카테고리화 하기도 좋고..
    
    ```
    class Values {
      this.maxRange = 10
      this.minRange = 1
    }
    
    ```
    

### 패키지와 모듈은 모두 소문자로 쓴다

-   이 부분도 영어 표기 원칙과 다름
    -   패키지와 모듈의 지위 > 클래스의 지위 지만 모두 소문자만 사용
    -   패키지와 모듈은 컨테이너(포장지)의 의미라 포장지보단 내용물이 중요하기 때문
    -   혼동을 방지하는 차원의 실용적인 이유도 있음

### BEM 표기법

-   CSS에서 사용하는  [BEM 표기법](https://nykim.work/15)은 ‘대상–요소__상태’를 의미
-   ‘Block–Element__Modifier’
-   대상의 요소나 부분을 의미할 때는 언더스코어 두개 (__)로 연결
-   대상이나 요소의 상태나 속성을 의미할 때는 하이픈 두개 (–)로 연결
    
    ```
    .form { }
    .form__button { }
    .form__button--disabled { }
    
    ```
    

### 가독성과 소통이 먼저다

### i는 변수 이름이지만 d는 아니다

-   가장 많이 쓰는 변수 이름 ?
    -   i, LOG, result ( “오픈소스의 네이밍 특징들” 자료)
    -   i : 정수의 integer 혹은 index의 i
    -   index 변수로 2차원, 3차원으로 확장시 j, k도 많이 쓰임
    -   x, y : 역시 좌표값을 의미, 수학에서 많이 쓰는 변수들
-   a, d 같은 의미 없는 이름은 곤란함
    -   d는 day? date? double? 고정된 의미를 유추하기 힘듬
-   의미를 유추할 수 있는 좋은이름
    
    ```
    int daysSinceCreated
    int monthSinceUpdated
    int yearsSinceRegistered
    
    ```
    

### 긴 이름? 짧은 이름? 검색 잘 되는 이름!

-   자동 완성 기능
    -   초창기 코딩 환경: 자동 완성이 어려웠던 시절
        -   numberOfTotalVeryImportantPersons 대신 VIPs
        -   maxSizeOfWindow 대신 ms
        -   그리고 용어사전에 설명으로 등록
        -   긴 변수 이름은 오탈자 나기 쉬웠던 환경
    -   최신 환경에서는 긴 이름 때문에 오탈자 나기 쉽다고 할 수 없음
-   접두어 - 헝가리안 표기법
    -   멤버 변수의 접두어는 m
    -   변수 타입에 따라 i, is를 붙이기도 함
    -   UI 구성 요소의 btn, img도 있음
    -   요즘 에디터는 변수 타입이 자동으로 표기되며, 정적분석을 통해 문제가 있을 경우 알려주기도 함
    -   위의 표기법은 레거시(유적)가 되었다고 볼 수 있음

### 복수형을 나타내는 s를 붙일까 말까?

-   복수형을 나타내는 -s 접미사는 간단한 변수명에서는 눈에 띄지만..
-   다음과 같이 함수명 중간에서는 잘 안보인다.
    
    ```
    checkUserNamesUnder2Characters()
    checkUserNamesExistsInDB()
    
    ```
    
-   다음과 같이 바꾸는 것이 나을 수도 있다 (-Array, ListOf- 로)
    
    ```
    checkUserNameArrayUnder2Characters()
    checkListOfUserNameExistsInDB()
    
    ```
    

## 03_ 좋은 이름의 기준, SMART

## 04_ 좋은 코드에는 주석이 없다?

## 05_ 다른 개발자를 배려하는 주석 쓰기

# 3장 : 사용자와 소통하는 에러 메시지 쓰기

## 01_ 에러 메시지를 쓰기 전에 에러부터 없애자

## 02_ 사용자 에러 메시지를 제대로 쓰는 법

## 03_ 사용자의 에러를 줄이는 메시지 구조화

## 04_ 에러 메시지 대신 예방 메시지를 쓰자

# 4장 : 독자 관점에서 릴리스 문서와 장애 보고서 쓰기

## 01_ 체인지 로그를 분류, 요약, 종합하는 법

## 02_ 고객에게 유용한 정보를 쓰자

## 03_ 릴리스 문서는 문제 해결 보고서처럼 쓰자

## 04_ 비즈니스를 이해하는 장애 보고서 쓰기

# 5장 : 설명, 묘사, 논증, 서사로 개발 가이드 쓰기

## 01_ 서비스 개념을 범주, 용도, 특징으로 설명하기

## 02_ 정확히 이해하도록 그림과 글로 묘사하기

## 03_ 논증으로 유용한 정보를 제공하자

## 04_ 서사를 활용해 목차를 만들자

# 6장 : 수주를 돕는 SI 제안서 쓰기

## 01_ 개발자가 알아야 할 제안서 작성 원칙

## 02_ 고객의 문제 인식과 제안사의 문제 해결 능력

## 03_ 고객의 요구사항은 변할 수밖에 없다

## 04_ 고객의 총 만족도를 높이자

# 7장 : 기술 블로그 쉽게 쓰고 운영하기

## 01_ 기술 블로그를 쉽게 쓰는 방법 3가지

## 02_ 글의 종류별로 목차 잡는 법 I - 저술

## 03_ 글의 종류별로 목차 잡는 법 II - 편집

## 04_ 기업의 기술 블로그 운영 팁

# 에필로그 : 회사가 개발자 글쓰기 교육을 하자

-   회사에서 개발자 글쓰기 교육을 할 수있는 여러가지 코스를 제안함
-   문의 사항은 저자 이메일로  `vitaminq42@gmail.com`
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTE3Nzg4MTY5NzIsMTg1NTc0MjE5MSwtMT
cxMzgyNDA1MCwxOTI0Mjc5NDAsLTExMTIzNjczNzcsNzMwOTk4
MTE2XX0=
-->