# [[The Vim Way] 00 The Vim Way](https://coldmater.tistory.com/208)

-   coldMater
-   [개발도구 / vim](https://coldmater.tistory.com/category/%EA%B0%9C%EB%B0%9C%EB%8F%84%EA%B5%AC/vim)
-   2021. 11. 7.

## The Vim Way 연재 시작

[The Vim Way] 이라는 이름으로 포스팅 연재를 시작하려고 한다.

각 편마다 Vim 을 사용하는 데 유용한 상황들을 설정하고, 그것을 직접 실습해보는 것이다.

![](https://blog.kakaocdn.net/dn/EYpWl/btrj3hbUktT/Ou1L3KD3MXpoPBdnz0jCvK/img.jpg)

The Vim Way 라는 말은 이 책(Practical Vim)에서 인용했다.

### The Vim Way 에서 다룰 것

이 글이 Vim 조작법을 다루는 다른 글들과는 다르게 '주요하게 사용되는 Vim 기능'만을 다룰 것이다. 그 중에서도 '문서 편집 기능'에 집중하여 포스팅을 하려고 한다.  **3년동안 Vim 을 써온 경험으로부터 추출한 일종의 꿀팁들이다.**

필자는 약 3년정도 Vim 을 주 편집용 에디터로 사용해오면서, 자주 사용하게 되는 주요 기능들을 정리할 수 있는 수준에 이르게 되었다. 각 포스팅마다 Vim 이 특별히 유용한 상황들을 가정하고, Vim 을 통해 어떻게 원하는 동작(편집)을 수행할 수 있는지 알아볼 것이다.

### The Vim Way 에서 다루지 않을 것

이는 리눅스 위에서 실행되는 '진짜 vim' 을 '제대로' 활용하는 방법과는 조금 거리가 있을지도 모른다. 가령, VIM 커맨드 라인을 제대로 활용하는 방법이라든가, 운영체제와의 상호작용 등 어쩌면  **매니악한 vim 의 기능을 다루지는 않는다**.

또한, 순수 Vim(커맨드라인에서 vi 명령어로 실행되는)을 IDE 로써 다루는 방법도 [The Vim Way] 연재와는 거리가 있다.

프로그래밍을 한다면 거의 대부분 IDE 를 활용한다. 해당 IDE 에서  **Vim 을 플러그인으로 설치하여 사용하는 경우에 본 포스팅이 특히 도움**이 될 것이다. 물론, IDE 위가 아닌 진짜 Vim 에서도 여기서 다룬 모든 내용은 유효하다.

### 왜 이 연재가 유용한가

Vim 은 배우기에 매우 많은 코스트가 소요된다. 배울 것도 많고 연습도 많이 해야 한다. Vim 3년의 경험을 참기름 짜듯이 꼭 필요한, 그리고 유용한 기능들만을 골라 소개한다. Vim 의 기능을 한정적으로만 사용했다면, 이 연재들을 통해서 더 깊고 풍부한 기능들을 사용할 수 있게 될 것이다.

Vim 을 사용한다는 것은 마우스를 대체한다는 것 그 이상의 의미가 있다. Vim 의 철학을 이해하고 나면, 반복작업이 특히 많은 Code Editing 작업을 얼마나 아름답게 수행할 수 있는지 깨닫게 될 것이다.

Vim 을 이미 사용하고 있는가?  **그렇더라도 당신은 Vim 을 제대로 사용하고 있지 않을 가능성이 크다!**  이 연재를 통해 Vim 을 제대로 이해하길 바라며, 당신의 코딩 스킬에 Vim 이라는 도구가 하나의 니트이 될 수 있길 바란다.

또한, 가능하면 gif 무빙 스크린샷(?)을 추가하여, 해당 명령이 어떻게 수행되는지 보여주고자 했다. 이는 눈으로 훑어보는 것만으로 vim 의 기능을 파악하는 데 도움이 될 것이고, 추후에 해당 기능이 필요하게 된 시점에 돌아와 찾아볼 수 있도록 기억하는 데 도움을 줄 수 있을것으로 기대된다.

### 사용하는 툴

대부분의 gif 는 VSCode 에서 Vim Extension 을 설치하여 촬영할 예정이다. 그러니, [The Vim Way]에 내용들을 따라해보고자 한다면, Visual Studio Code (VSCode) 에 Vim Extension 을 설치하여 실습해볼 수 있다.물론, JetBrains 류 IDE (intelliJ, Webstorm, PyCharm 등) 에서도 모두 Vim 을 Extension 으로 지원하고, Vim 사용법 자체는 툴들마다 거의 동일하므로, 굳이 VSCode 에서 진행할 필요는 없다.

----------

다음 포스팅에서 Vim 의 실행방법과, 초심자들을 멘붕에 빠뜨리는 Vim 을 종료하는 방법을 알아본다.


# [[The Vim Way] 01 Vim 기본조작 - Vim 의 실행과 종료](https://coldmater.tistory.com/209)

-   coldMater
-   [개발도구 / vim](https://coldmater.tistory.com/category/%EA%B0%9C%EB%B0%9C%EB%8F%84%EA%B5%AC/vim)
-   2021. 11. 7.

## Vim 기본 조작법

Vimic(Vim 을 사용하기에 적절한) 상황을 보기에 앞서, 간단히 Vim 기본 조작법을 알아보고자 한다.

### Vim 실행하기

보통 IDE 에서는 Vim 플러그인을 설치하고, 'Vim 사용하기' 설정을 켜두면 에디터에서 Vim 으로 작동한다.

리눅스 또는 윈도우 커맨드라인 환경에서는 'vi', 'vim' 을 입력하여 vim 프로그램을 실행할 수 있다.

![](https://blog.kakaocdn.net/dn/cpsUh8/btrmYcS5pTP/uqcYVfZadiGGSkDgyptOiK/img.gif)

windows powershell 에서 vim 실행하기 (vim 을 입력해도 된다.)

### Vim 강제 종료하기

의외로 많은 초심자들이 Vim 으로부터 빠져나가는 방법을 몰라 쩔쩔매는 상황이 많다고 한다. 이 명령어들을 먼저 배우는게 순서상으로 올바르진 않지만, 그래도 급한 분들을 위해 먼저 소개한다. 일단 다음을 그대로 따라서 Vim 을 종료해보자. 다음 각 순서에 명시된 키만 순서대로 입력하면 된다.

1.  ESC  를 연타한다.
2.  쌍따옴표(:) 를 입력한다.
3.  q  를 입력한다.
4.  !  를 입력한다.
5.  Enter를 누른다.

![](https://blog.kakaocdn.net/dn/AOI8t/btrkOjZXWAJ/vYIL6dkVJidpVsKoKDXvuK/img.gif)

vim 종료하기 :q!, 하단 status bar 에 입력되는 내용에 주목하자.

이렇게 Vim 으로부터 빠져나올 수 있다. 단, 이렇게 빠져나오게 되면 수정했던 내용은 모두 사라지게 된다.

### Vim 저장하고 종료하기

위 강제 종료하기 과정에서 3. 의 과정만 살짝 변경해주면 된다.

1.  ESC  를 연타한다.
2.  쌍따옴표(:) 를 입력한다.
3.  wq  를 입력한다.
4.  !  를 입력한다.
5.  엔터를 누른다.

3. 의 과정이 q 에서 wq 로 변경되었다. 그렇다. w 는 Vim 에서 '저장'을 의미한다.

실제 Vim 프로그램은 그 프로그램이 종료가 되지만, 보통 IDE 에서는 종료 명령어를 수행하게 되면, 에디터 '탭'이 꺼지게 된다.

![](https://blog.kakaocdn.net/dn/bVAqpA/btrkQliTTLv/Xsdn54e3TBG8rt9PtKlEo0/img.gif)

&nbsp;vi 로 수정한 내용을 저장하고 종료하기 위해서는 :wq 를 입력한다. (! 는 강제라는 뜻을 의미한다.)

----------

위 각 순서에서 명시한 키는 모두 각자의 의미가 있다. 다음 포스팅에서 Vim 의 3가지 모드에 관해서 알아보도록 하자.


# [[The Vim Way] 02 Vim 기본조작 - Vim 의 4가지 모드](https://coldmater.tistory.com/210)

-   coldMater
-   [개발도구 / vim](https://coldmater.tistory.com/category/%EA%B0%9C%EB%B0%9C%EB%8F%84%EA%B5%AC/vim)
-   2021. 11. 7.

## Vim 의 네 가지 모드

Vim 에는 4가지 모드가 있다. 일단 4가지 모드가 있다는 사실만 인지하고 넘어가자.

-   Normal Mode
-   Insert Mode
-   Command Mode
-   Visual Mode

현재 어떤 모드인지는 에디터 하단 Status Bar 에서 확인할 수 있다. 그럼 각 모드에 대해 필요한 내용만 신속히 알아보도록 하자.

### Normal Mode

Vim 을 처음 켰을 때, 또는 IDE 에서 에디터를 처음 켰을 때의 모드이다. 이 상태에서는 주로 두 가지 일을 수행한다.

-   커서를 움직인다.
-   명령을 수행한다.

보통 IDE 에서는 Normal 모드인 경우 커서가 두껍게 반짝인다.

다음은 VSCode 에디터에서 Vim 플러그인을 실행한 모습이다. 대부분의 IDE 에서 비슷하게 표현된다.

![](https://blog.kakaocdn.net/dn/rSQ5S/btrj7RpuY3A/j4FnJuDrN7cEIgRYcoM9MK/img.png)

화면 하단에 --NORMAL-- 로 현재 모드가 표현되어 있다.

도서 [Practical Vim] 에서는 이 모드를 화가가 캔버스에서 붓을 뗀 상태로 비유했다.

### Insert Mode

Normal 모드에서 알파벳 i 를 누른거나, 알파벳 a 를 누르면 Insert Mode 로 진입할 수 있다.

다시 이 상태에서 ESC 를 누르면 Normal 모드로 빠져나오게 된다.

Insert 모드에서 주요한 기능은 다음과 같다.

-   문자열 입력

사실, Insert 모드는 타이핑을 하는것이 주된 목적이지만, 커서를 이동할 수도 있고, ctrl 키와 조합하여 일련의 명령을 수행할 수도 있다.

![](https://blog.kakaocdn.net/dn/LeMGM/btrj4Xqe0lC/J0JGk1HRDZZa2DasCcPQb0/img.png)

화면 하단에 --INSERT-- 로 현재 모드가 표현되어 있다.

도서 [Practical Vim] 에서는 이 모드를 화가가 캔버스에서 붓을 가져다 댄 상태로 비유했다.

여기서는 간단히 Insert Mode 에 진입할 수 있는 방법을 2가지만 소개했지만, 더욱 많은 Insert 모드 진입방법이 존재한다. 이 부분은 추후에 다시 알아보도록 한다.

### Command Mode

Normal 모드에서 콜론(:) 을 입력하여 Command Mode 로 진입할 수 있다.

![](https://blog.kakaocdn.net/dn/dumAIS/btrj6c1MifS/OmItmlCf5xn3zkBvEnDsU0/img.png)

상태창에 : 으로 시작되는 커서가 생겼다. 여기에서 특정 명령어를 입력하여 해당 명령을 실행시킬 수 있다.

문서의 내용에 대한 편집 외의 기능들을 수행할 수 있다. 앞선 포스팅에서 살펴봤듯이, Command Mode 에서는 문서의 저장과 종료를 수행할 수 있었다. 그렇기에 종료 동작의 맨 앞에 콜론(:)이 포함되는 것이다.

Command Mode 에서는 주요하게 다음과 같은 동작들을 수행한다.

-   문서의 저장
-   프로그램(또는 탭) 종료
-   문자열 찾기, 바꾸기

다른 모드들과 마찬가지로 ESC 를 입력하여 Normal 모드로 복귀할 수 있다.

### Visual Mode

Normal 모드에서 ctrl-V 또는 shift-V 를 통해서 Visual Mode 에 접근할 수 있다.

(엄밀하게 ctrl-V 는 visual block 모드, shift-V 는 visual line 모드를 의미함)

GUI 환경에서는 마우스로 드래그를 하여 '블럭'을 씌우는데, 그 역할을 수행하는 모드이다.

![](https://blog.kakaocdn.net/dn/bf65Vq/btrj6c1MiBh/4xJKrKVGmz1ZIrkVHyWpy0/img.png)

Visual 모드, Shift + V 로 한 줄을 선택할 수 있고, 이를 Visual Line 모드라고 한다.

즉, Visual Mode 의 목적은 단 하나다.

-   문서 내 범위 지정

마찬가지로 ESC 키로 Normal Mode 로 빠져나갈 수 있다.

## Vim 의 4가지 모드에 대한 도식화

이상을 도식화 하면 Vim 의 모드들은 다음 그림과 같은 관계로 표현할 수 있다.

![](https://blog.kakaocdn.net/dn/c9f08F/btrj9mpw2af/OgTY0bAufXjweQiTbX3gi1/img.png)

Vim 의 4가지 모드

----------

다음 포스팅에서는 Normal 모드에서 커서를 이동시키는 방법에 대해서 알아보도록 하자.


# [[The Vim Way] 03 Vim 기본조작 - Normal Mode 에서의 커서 이동](https://coldmater.tistory.com/211)

-   coldMater
-   [개발도구 / vim](https://coldmater.tistory.com/category/%EA%B0%9C%EB%B0%9C%EB%8F%84%EA%B5%AC/vim)
-   2021. 11. 8.

이 포스팅에서는 GUI 환경에서 마우스를 활용하여 커서를 이동시킬 수 있는 동작들을, Vim 에서는 어떻게 수행할 수 있는지 알아본다. 당장 익혀서 실전에 적용할 수는 없겠지만, 여기서 이런 것들이 가능했다는 사실들을 인지해두고, 나중에 코딩을 하다가 '그런 기능이 있었지'라며 돌아와서 찾아보기에 유용한 포스팅이 되길 바란다.

## Vim 에서의 방향키 h, j, k, l

Vim 은 마우스가 대중화되기 이전에 개발된 텍스트에디터인 Vi 를 모체로 한다. 아마도 당시 키보드에는 방향키가 없었던 모양인지, 일반 qwerty 배열 키보드의 h, j, k, l 키에 각각 좌, 하, 상, 우 를 할당했다. (Vim 과 자주 비교되는 emacs 의 경우에는 i, j, k, l 의 방향키와 비슷한 배열로 상하좌우를 움직일 수 있다.)

요즘 시대에 실제 방향과는 조금 무관하게 보이는 h, j, k, l 로 커서를 움직인다는게 어색하긴 하지만, 연습을 하고 익숙해지면, 생각을 거치지 않고도 바로 커서를 움직일 수 있게 된다.

⚠ 현재 Vim 이 Normal 모드인지 확인한다. (Vim 이 실행된 상태 또는 IDE 에서 활성화된 상태라면 ESC 를 눌러 Normal 모드로 빠져나갈 수 있다.)

### 좌우 이동

-   h 키로 좌로 움직일 수 있다.
-   l 키로 우로 움직일 수 있다.

일단 vim 에서 기본 방향키가 h, j, k, l 임으로부터, h 는 맨 왼쪽에 있고, l 은 맨 오른쪽에 있다. 이로써 이 둘은 좌, 우 로의 이동임을 유추할 수 있다.

![](https://blog.kakaocdn.net/dn/dRLN0p/btrkcswkPhT/BDm8IpbPhHjg0pqWi9TNB1/img.gif)

Vim 노멀 모드에서의 좌우 이동

### 상하 이동

-   j 키로 아래로 움직일 수 있다.
-   k 키로 위로 움직일 수 있다.

왜 j 가 아래이고, k 가 위인지는 모른다. 때론 있는 그대로 받아들여야 하는 경우가 있다.

![](https://blog.kakaocdn.net/dn/Rseck/btrkaPefmwy/x1ceSuOKAN52BISDS7o5u1/img.gif)

Vim Normal 모드에서의 상하이동

## Vim 에서의 라인 점프 (줄단위 이동)

### 문장(line)의 시작과 끝으로 이동하기

-   $(shift + 4) 키로 문장의 끝으로 이동할 수 있다.
-   ^(shift + 6) 키로 문장의 시작으로 이동할 수 있다.
-   0 키로 라인의 첫번째 컬럼으로 이동할 수 있다. (cf. ^)

정규표현식에서 $ 는 문장의 끝을 의미하고, ^ 는 문장의 시작을 의미한다. 마찬가지로, vim 에서는 해당 키로 문장의 시작과 끝을 한번에 움직일 수 있다.

h 키를 반복하여 누르거나, l 키를 반복하여 눌러 문장의 시작과 끝으로 이동할 수도 있다. 하지만 Vim 은 골프와 같다. 어떻게 하면 키 입력을 최소화하여 원하는 결과를 이룰 수 있을지 고민해야 한다.

![](https://blog.kakaocdn.net/dn/b22X18/btrj7So0Zja/wBKcg7CZ7TzGHikbolWUSk/img.gif)

Vim 에서 문장의 시작과 끝으로 이동하기

여기서 한가지 짚고 넘어가야 할 것은, 문장의 시작과, 라인의 첫 컬럼으로 이동할 수 있는 키가 분리되어있다는 것이다.

^는 문장의 시작으로 이동하는데, 공백이 아닌 첫 번째 문자가 나타나는 위치로 이동한다는 의미이다.

반면, 0은 라인의 공백과는 상관 없이 맨 첫번째 컬럼(0번)으로 이동한다.

굳이 이렇게까지 나눠놓은 이유가 있겠냐싶지만, 추후에 매크로라든지를 활용하여 특정 작업을 수행할 때, 두 명령이 분리되어있다는 것이 유용하게 다가옴을 느낄 수 있을 것이다.

![](https://blog.kakaocdn.net/dn/bPW7uu/btrj7RwUgWk/ks3yCiFDuv6NsSQpnXvjyk/img.gif)

Vim ^(shift + 6) 과 0 의 차이

### 문서의 특정 라인으로 이동하기

-   (라인번호 입력) + gg 키로 해당 라인넘버로 점프할 수 있다. (또는, gg 대신 G 를 입력해도 된다.)

Vim 을 가볍게 사용하는 예 중에 하나는, 서버에 쌓여있는 로그를 확인하는 것이다. 물론 tail 명령어라는 좋은 대안이 있기도 하지만, Vim 으로 수천~수만 라인에 달하는 로그를 확인해야 하는 경우가 있을 수 있다.

이 때, 특정 라인으로 점프할 수 있는 기능을 Vim 에서 제공한다.

![](https://blog.kakaocdn.net/dn/TUyje/btrj4ovrzag/GkoQE0tnimFaOu3oSCaQok/img.gif)

&amp;amp;amp;nbsp;Vim 에서 특정 라인 넘버로 이동하기

문서가 14줄 밖에 안되지만, 100gg 를 입력하니 문서의 맨 끝으로 이동했다.

### 문서의 시작 라인, 끝 라인으로 이동하기

-   shift + g 키로 문서의 끝 라인으로 이동할 수 있다.
-   gg 키로 문서의 시작 라인으로 이동할 수 있다.

숫자 입력 없이 gg 를 입력하면 문서의 시작 라인으로 이동한다. G (= shift + g) 키로 문서의 마지막 라인으로 이동한다.

특히, 라인 수가 굉장히 많은 파일일 경우에 유용하다.

![](https://blog.kakaocdn.net/dn/bqE92T/btrj3YiUSn9/DTedt5I9dJOaRI3QOjk3Y1/img.gif)

Vim 에서 문서의 시작라인과 종료라인으로 이동하기

### [비개발용] 마침표를 기준으로 한 문장의 시작과 끝으로 이동

-   ( 키는 마침표를 기준으로 이전 문장의 시작 위치로 이동한다.
-   ) 키는 마침표를 기준으로 다음 문장의 시작 위치로 이동한다.

Vim 은 꼭 프로그래머를 위해서만 개발된 것은 아니다. 글을 쓰는 작가에게도 Vim 은 유용할 수 있다. 하지만, 이 기능은 프로그래머에게는 그다지 유용하지 않다. 프로그래머에게 마침표는 종료보다는 참조의 의미로 쓰이는 경우가 많기 때문이다.

![](https://blog.kakaocdn.net/dn/bh0yC6/btrj88Faed4/JFWypZbQmnAbPlaWMNC1s0/img.gif)

마침표를 기준으로 문장간 이동

## Vim 에서의 페이지단위 이동

GUI 환경에서의 마우스 스크롤에 해당하는 기능이라고 볼 수 있다.

### 반 페이지 단위 이동

-   Ctrl + u 키로 반페이지 위로 이동할 수 있다.
-   Ctrl + d 키로 반페이지 아래로 이동할 수 있다.

일반 풀배열 키보드에는 방향키 위쪽에 PageUp 키와 PageDown 키가 존재한다. 이는 페이지 단위를 이동하는 데 매우 유용하다. Vim 에서도 이와 같이 페이지 단위로 이동할 수 있는 단축키를 제공한다. 단축키를 나타내는 키보드는 각각 up 과 down 을 의미하므로 기억하기에도 쉽다.

![](https://blog.kakaocdn.net/dn/bJK805/btrkeg3pJW1/qo52ehzPtGky5amWXU3iDK/img.gif)

Vim 에서의 반페이지 단위 이동

### 한 페이지 단위 이동

-   Ctrl + b 키로 반페이지 위로 이동할 수 있다.
-   Ctrl + f 키로 반페이지 아래로 이동할 수 있다.

반 페이지 단위 이동과 동일하게 작동한다. 다만, 더 많은 라인을 점프하는 것을 확인할 수 있다. 단축키를 나타내는 키보드 또한 직관적이다. b 는 backward 를, f 는 forward 를 의미한다.

![](https://blog.kakaocdn.net/dn/zSA88/btrj4nXC8c1/9czSzvPRBeAakC8uvnuik1/img.gif)

Vim 에서의 한 페이지 이동

## 단어 이동

Vim 에서는 h, j, k, l 로 기본적인 커서 이동을 할 수 있고, 사실 이 네 개의 키만으로도 커서를 원하는 위치로 '언젠가는' 이동시킬 수 있다. 하지만, Vim 을 사용하는것이 무언가 시원스런 코드 입력이라면, 이 챕터를 주목할 필요가 있을 것이다. 프로그래밍이라는 행위는 기계에게 해야할 일을 명확히 지시하는 것이다. 마찬가지로, 우리가 현실 속에서 '오른쪽으로 조금만 더' 와 같은 애매한 표현은 컴퓨터에게 적절하지 않다. 다시, 나중에 배울 매크로와 결합된다면, 여기서 익혀둔 커서 이동은 큰 도움이 될 것이다.

### 다음 단어의 첫 글자로 이동

-   w 키로 맥락상(?) 다음 단어의 첫 글자로 이동한다.
-   W 키로 공백기준으로 다음 단어의 첫 글자로 이동한다.

w (소문자)는 맥락상 특정 구분기호(" 나 . 같은)를 기준점으로 이동한다. 반면, W(대문자)는 명확히 공백을 기준으로 다음 단어의 시작으로 이동한다. word 의 앞글자를 의미한다.

하나 기억해둘 것은, 다음에 소개할 b, e 의 동작과는 다르게 무조건 다음 단어로 점프한다는 것이다.

w (소문자) 키를 '맥락상'이라고 표현하고 만 이유는, 우리가 w 로 이동할 때 정확히 어떤 구두점을 기준으로 점프하는지 외우는 것은 너무 소모적이라고 판단했기 때문이다. (이를 외워서 정확하게 이동하면 더할나위 없이 좋기도 하겠지만 추후 특정 문자로 이동할 수 있는 기능(f 키)이 대안이 될 수 있다.) 보통 원하는 단어의 첫 글자의 위치에 커서가 위치할 때까지 w 키를 반복해서 누를 수 밖에 없다.

보통 l 키를 활용하여 라인의 오른쪽으로 이동하는데, 이게 시원치 않을 경우 w 키로, 이마저도 시원치 않을 경우 W 로 이동하자.

![](https://blog.kakaocdn.net/dn/yBRsa/btrkcrqFdIO/aYF8LthQvsQk9UVAaneJ6K/img.gif)

Vim 의 다음 단어의 첫 글자로 이동하기 w 와 W

### 다음 단어의 끝 글자로 이동

-   e 키로 맥락상(?) 커서가 위치한 단어 또는 다음 단어의 끝 글자로 이동한다.
-   E 키로 공백기준으로 커서가 위치한 단어 또는 다음 단어의 끝 글자로 이동한다.

w 키와 마찬가지로 움직이지만, 단 한가지의 차이점은 단어의 맨 뒤에 커서가 위치한다는 것이다. end of word 의 앞글자를 땄다고 생각하면 될 것 같다.

굳이 w 키가 있는데 왜 또 e 키에 해당하는 명령어를 만들었는지 의아할 수도 있을 것이지만, 이 또한, 나중에 Vim 의 진짜(?) 기능을 체험하게 될 텐데, 그 때 비로소 진가를 발휘한다.

하나 기억해둘 것은, 현재 단어의 끝 글자로 먼저 이동한다는 것이다. 현재 단어의 끝 글자에 위치한 다음에야 비로소 다음 단어의 끝 글자로 이동한다.

![](https://blog.kakaocdn.net/dn/b7ZFDP/btrj89jM1NX/DeApt2kQF6F404JD1oq2k0/img.gif)

Vim 의 다음 단어의 끝 글자로 이동하기 e 와 E

### 이전 단어의 첫 글자로 이동

-   b 키로 맥락상(?) 커서가 위치한 단어 또는 이전 단어의 첫 글자로 이동한다.
-   B 키로 공백기준으로 커서가 위치한 단어 또는 이전 단어의 첫 글자로 이동한다.

back 을 의미한다. w, e 를 통해 전진했다면, b 를 통해 후진할 수 있다.

하나 기억해둘 것은, e 의 동작원리와 마찬가지로, 현재 단어의 첫 글자로 먼저 이동한다는 것이다. 현재 단어의 첫 글자에 위치한 다음에야 비로소 이전 단어의 첫 글자로 이동한다. 즉, b 키와 e 키를 번갈아 누른다면 커서는 커서가 위치한 단어의 첫 글자와 끝 글자를 왔다갔다 할 것이다.

![](https://blog.kakaocdn.net/dn/ULG2R/btrj7xSq0W9/SGfuqIqeyXUcolkyuD0pUk/img.gif)

Vim 의 이전 단어의 시작 글자로 이동하기 b 와 B

### 이전 단어의 끝 글자로 이동

-   ge 키로 맥락상(?) 커서가 위치한 단어의 이전 단어의 끝 글자로 이동한다.
-   gE 키로 공백기준으로 커서가 위치한 단어의 이전 단어의 끝 글자로 이동한다.

g 는 독립적인 명령어가 아니고, g 이후에 추가로 키를 입력해야 비로소 의미를 갖는다. Vim 에서는 키보드의 각 입력에 모든 명령을 할당할 수 없었기에 확장된 명령어는 g 키와 조합하여 수행하게 설계되어있다. 이전에 살펴보았던 gg 도 동일한 맥락이라고 볼 수 있겠다.

e, E 가 다음 단어의 끝으로 이동하라는 의미였다면, ge, gE 는 그 반대의 의미를 갖는다.

![](https://blog.kakaocdn.net/dn/Wxow7/btrlvB7Z2Gg/CGrK3PF4EPLnhQ3XXtWL5K/img.gif)

Vim 이전 단어의 끝 글자로 이동하기 ge, gE

## Vim Cheat Sheet 에서 커서 이동 살펴보기

![](https://blog.kakaocdn.net/dn/cMfREo/btrkHJS6f9M/O0b6zk4EsYKA2rWKAFIyT1/img.png)

Vim Cheat Sheet (출처를 알 수 없어 표기하지 못했다. 혹시 알고 있다면 코멘트를 부탁한다. 오른쪽 화살표 옆 url 은 유효하지 않았다.)

Google 에서 Vim Cheat Sheet 를 검색하면 여러 vim cheet sheet 들을 볼 수 있는데, 위 cheet sheet 가 vim 의 커서 이동에 관해서 가장 잘 시각화 되어있다. 강조되어있다는 것은 제작자가 그만큼 중요하고 유용하다고 판단해서였을 것이다. 이걸 보는 당신은 아직 위 cheat sheet 에 나와있는 모든 내용을 파악할 필요가 없다. (그랬다간, vim 익히기를 포기하게 되는 지름길을 걷게 되는 수가 있다.)

우리가 이 cheet sheet 에서 지금 당장 뽑아낼 것은, 좌측 상단 회색음영으로 된 큰 상하좌우 화살표이다. 화살표의 방향은 실제로 그 방향으로 움직이는 것을 의미하고, (좌우 - 단어단위, 상하 - 줄단위) 중심에서 가까울수록 작은 이동, 멀어질 수록 많은 이동을 의미한다. 이렇게 시각화한 원작자의 아이디어에 경의를 표한다.

이번 포스팅에서 살펴보았던 이동키들을 위 아이디어를 따라 다시 정리해보면 다음과 같다.

![](https://blog.kakaocdn.net/dn/CYAht/btrkIinKLSG/RLkjfrW8p6auJManRoIvM0/img.png)

Vim Normal Mode Movement: Vim Normal Mode 에서 커서를 이동하는 다양한 방법

----------

이번에는 Vim Normal 모드에서 커서를 이동시키는 다양한 방법을 알아보았다.

사실, 커서를 이동하는 방법은 이 외에도 몇가지가 더 있다. 가령, 특정 문자로 이동하다든가, 찾기 기능을 활용해서 이동하다든가 하는 기능들이 더 있다. 이는 별도의 포스팅에서 다룰 예정이다.

적어도, 여기서 소개한 노멀모드 커서 이동 명령들은 매우 자주 사용되기 때문에 반드시 익혀두어야 한다.

다음 포스팅에서는 Normal 모드에서 Insert 모드로 집인하는 방법과 함께 문서에 원하는 문자열을 입력하는 방법을 다뤄보도록 하자.

# [[The Vim Way] 04 Vim 기본조작 - Insert Mode 진입과 문자 입력하기](https://coldmater.tistory.com/213)

-   coldMater
-   [개발도구 / vim](https://coldmater.tistory.com/category/%EA%B0%9C%EB%B0%9C%EB%8F%84%EA%B5%AC/vim)
-   2021. 11. 9.

[](https://coldmater.tistory.com/210)

[The Vim Way] 02 Vim 기본조작 - Vim 의 4가지 모드

Vim 의 네 가지 모드 Vim 에는 4가지 모드가 있다. 일단 4가지 모드가 있다는 사실만 인지하고 넘어가자. Normal Mode Insert Mode Command Mode Visual Mode 현재 어떤 모드인지는 에디터 하단 Status Bar 에서..

coldmater.tistory.com

Vim 의 4가지 모드에서 살펴보았듯, Vim 에는 문서에 직접 타이핑을 해 넣을 수 있는 Insert 모드가 존재한다. 한국어로는 삽입모드라고 할 수 있겠다.

## Vim Insert Mode

Vim Insert Mode에서 할 수 있는 일은 다음과 같다.

-   문서에 문자열을 타이핑하여 넣을 수 있다.

### 일반 워드프로세서와 Vim 이 다른 점

보통 '문서 편집'이라면 키보드로 어떤 문자열을 입력하는 것이 기본 기능일 것이다. 가령 MS-Word 나 한글과컴퓨터-한글 과 같은 프로그램을 켜면 하얀 바탕에 커서가 반짝이고, 키보드를 타건하는 순간 우리가 누른 키에 해당하는 문자가 입력된다.

하지만 Vim 은 켜자마자 Normal 모드이고, 이 모드에서는 타이핑하여 문자를 입력할 수 없다. (Normal Mode 의 주 역할은 주로 커서의 이동과 특정 명령의 수행이다.) 일반 워드프로세서와 같이 문자열을 입력할 수 있는 상태로 변경하고자 한다면 Insert Mode 로 진입해야 한다.

## Vim 문자 입력하기

### Vim 에서 문자를 입력하는 방법

Insert Mode 를 탐험하기 전에 간단히 Insert Mode 가 동작하는 모습을 살펴보자.

1.  (Normal Mode 에서) i 키로 Insert Mode 로 진입한다.
2.  원하는 문자열을 타이핑한다.
3.  Esc 키로 Normal Mode 로 빠져나간다.

### Insert Mode 구분하기

#### Status Bar 로 확인하기

아래 스크린샷처럼, i 키와 esc 키를 누를 때 하단 status 에 --NORMAL--, --INSERT-- 처럼 현재의 상태가 바뀐 것을 확인할 수 있다.

![](https://blog.kakaocdn.net/dn/kY0Yv/btrkuJecKsT/Q6J8sH4upqrvkGkJOGqr70/img.gif)

vim insert mode 문자열 입력하기

#### Cursor 모양으로 확인하기

대중적인 IDE, 텍스트(코드) 에디터들에서는 스크린샷처럼 Normal Mode 에서는 두꺼운 커서를, Insert Mode 에서는 얇은 커서임을 확인할 수 있다. 얇은 커서는 현재 문자열이 입력될 정확한 위치를 지시해주시기 때문에 (글자 자체를 덮는) 두꺼운 커서보다 유용하다.

그러나, 간혹 레거시 시스템에서 Vim 을 사용하게 되면, Normal Mode 와 Insert Mode 에서의 커서가 서로 다르지 않는 경우(둘 다 두꺼운 커서로 표시된다.)를 볼 수 있는데, 그런 경우 하단 status bar 를 통해서 현재 어떤 상태인지 확인할 수 있다.

## Vim Insert Mode 진입하기

Vim 의 Insert Mode 는 위에서 설명했듯, 문자열을 타이핑하기 위한 모드이다. 그런데, 위에서 살펴본 i 키 말고도 Insert Mode 로 진입할 수 있는 여러가지 방법들을 제공한다. 여기서는 주요한 방법들을 몇가지 살펴보도록 하자.

### i - 커서 바로 왼쪽에 입력하기

-   i 키를 눌러 현재 위치한 커서의 왼쪽에서 Insert Mode 를 시작한다.

아래 스크린샷에서 괄호에 있던 두꺼운 커서 왼쪽으로 얇은 커서가 생긴 것을 확인할 수 있다. i 가 insert 를 의미한다고 볼 수 있다.

![](https://blog.kakaocdn.net/dn/EwrUn/btrkuHUXl7B/BVCwvI4wZLKbVKKiprKDjK/img.gif)

i 키를 눌러 커서 왼쪽에서 insert mode 시작하기

이제 vim 에서 insert mode 에 진입할 수 있는 방법을 알아보았다. 하지만, 이것만으로 충분하지 않다. vim 은 당신의 생각보다 강력하다. 다음에서 insert mode 로 진입하는 다양한 방법들을 알아보자. 이를 통해 상황에 맞게 효율적으로 insert mode 로 진입이 가능하다.

i 만을 Insert Mode 의 진입방법으로 알고 있는 사람이라면, 원하는 위치에서 Insert Mode 를 시작하기 위해 Normal 모드에서 커서를 복잡하고 힙겹게 이동하는 과정을 거쳐야만 한다. (또는 insert 모드를 시작한 뒤 방향키로 커서를 움직일 수도 있지만, 이는 권장하지 않는다. Normal Mode 에서 훨씬 강력한 방법으로 커서를 이동시킬 수 있는 방법을 대신 사용하는 편이 훨씬 효율적이기 때문이다.)

### a - 커서 바로 오른쪽에 입력하기

-   a 키를 눌러 현재 위치한 커서의 오른쪽에서 Insert Mode 를 시작한다.

아래 스크린샷에서 괄호에 있던 두꺼운 커서 오른쪽으로 얇은 커서가 생긴 것을 확인할 수 있다. a 가 append 를 의미한다고 볼 수 있다.

![](https://blog.kakaocdn.net/dn/LauKj/btrkqtiK0sX/rq1prmBvp5UPogSW81ELV1/img.gif)

a 키를 눌러 커서 오른쪽에서 insert mode 시작하기

### I - 줄의 맨 앞에 입력하기

-   I(shift + i) 키를 눌러 현재 커서가 위치한 줄의 맨 앞에서 Insert Mode 를 시작한다.

눈치챘겠지만 i 의 대문자인 I 커맨드는 i 의 의미를 확장(대문자)하여 '가장' 왼쪽에 삽입을 시작한다.

> 💡 Insert Mode 로 진입하는 명령어(a, i, c, o, s)는 모두 그 알파벳의 대문자에 대응하는 명령어(A, I, C, O, S)가 존재한다. 이 대문자 명령어 또한 모두 Insert Mode 로의 진입하는 기능을 수행하며, 대부분 소문자 명령어의 의미를 확장한 명령을 수행한다. (e.g. a 는 커서 왼쪽에 삽입, A 는 줄 맨 왼쪽에 삽입)

![](https://blog.kakaocdn.net/dn/cmRYyR/btrkwdr41lj/pgi9R2Om6aIl5yPGOWuqMK/img.gif)

현재 줄의 맨 앞에서 insert mode 시작하기

### A - 줄의 맨 뒤에 입력하기

-   A(shift + a) 키를 눌러 현재 커서가 위치한 줄의 맨 뒤에서 Insert Mode 를 시작한다.

눈치챘겠지만 a 의 대문자인 A 커맨드는 a 의 의미를 확장(대문자)하여 '가장' 오른쪽에 삽입을 시작한다.

![](https://blog.kakaocdn.net/dn/bMy6UW/btrkweqZdlH/kbyeEb5gE7friECoiP7pSk/img.gif)

현재 줄의 맨 뒤에서 insert mode 시작하기

### o - 아래 줄에 새 줄을 삽입한 뒤 입력하기

-   o 키를 눌러 현재 커서가 위치한 줄의 바로 아래 입력을 시작한다.

새로운 줄을 입력할 때 보통 커서를 줄의 맨 오른쪽에 위치시킨 뒤 엔터를 치곤 한다. 이 방법으로 그 즉시 커서 밑 줄에 새로운 줄을 삽입하고 입력을 시작할 수 있다. 보통 자동으로 들여쓰기가 되어있는데, 탭 간격은 설정을 따른다.

![](https://blog.kakaocdn.net/dn/c8cSKf/btrkvHmFsNz/LGssm6uAZsCZIm9ozZ0G2k/img.gif)

커서의 바로 밑에 새로운 줄을 삽입하고 insert mode 로 진입하기

### O - 위 줄에 새 줄을 삽입한 뒤 입력하기

-   O(shift + o) 키를 눌러 현재 커서가 위치한 줄의 바로 아래 입력을 시작한다.

눈치챘겠지만, o 커맨드의 반대 의미로 생각할 수 있겠다.

![](https://blog.kakaocdn.net/dn/bn4ohn/btrku2dv3As/BggqNOfKFLFRuHI3m3KKiK/img.gif)

커서의 바로 위에 새로운 줄을 삽입하고 insert mode 로 진입하기

### s - 삭제하고 입력하기

-   s 키를 눌러 현재 커서가 위치의 문자(또는 선택영역)를 삭제하고 입력을 시작한다.

말로 설명하기는 조금 애매한 부분이 있으니 스크린샷을 참고하면 명확히 이해할 수 있을것이다. 현재 커서의 문자를 삭제하고 바로 insert mode 를 시작한다.

![](https://blog.kakaocdn.net/dn/dHtwJd/btrkyPda87j/el2dT8xHY1PqaoMZ856vzk/img.gif)

커서 위치의 문자를 삭제하고 insert mode 로 진입하기

추후에 Visual Mode 를 사용하여 특정 범위를 지정한 뒤, 해당 범위를 삭제하고 삽입하는 것도 s 명령어로 가능하다.

### S - 현재 줄을 전부 삭제하고 입력하기

-   S(shift + s) 키를 눌러 현재 커서가 위치한 줄을 전부 삭제하고 입력을 시작한다.

![](https://blog.kakaocdn.net/dn/czCavq/btrktcOMRsg/zWnGFYhQqqHn1ptxM7cJAK/img.gif)

현재 커서가 위치한 줄을 전부 삭제하고 insert mode 로 진입하기

### C - 현재 커서의 오른쪽 전부를 삭제하고 입력하기

-   C(shift + c) 키를 눌러 현재 커서가 위치한 오른쪽 전부를 삭제하고 입력을 시작한다.

![](https://blog.kakaocdn.net/dn/kJ17Z/btrkweYOKSS/eUOHjVIUazvkRiEBWYlkk0/img.gif)

현재 커서 오른쪽의 모든 내용을 지우고 insert mode 로 진입하기

#### c - vim c 커맨드는?

c 는 insert mode 로 진입하는 커맨드이기는 하지만, c 키를 누른 뒤에 별도의 '목적어'에 해당하는 명령어(이 경우 vim 에서는 operator 라고 함)를 추가로 입력해주어야 한다. 이러한 특징을 가진 오퍼레이터들은 추후 포스팅에서 별도로 다루도록 한다. ('목적어'라는 표현에 의아할 독자들이 있을것이라고 생각한다. 그렇다. vim 은 컴퓨터가 그렇듯, '언어적으로' 문서를 편집할 수 있는 툴이기도 하다. e.g. Normal Mode 에서 vim 커맨드 `c3w` 는 다음을 의미한다. "현재 커서로부터 3 단어 지우고 insert mode 로 진입해줘.")

## Vim Normal Mode 진입

Vim 에서는 특정 모드에서 Normal Mode 로 빠져나가야할 일이 빈번하게 일어난다. 설명을 하지 않더라도, Esc 명령이 그 기능을 수행한다는 것은 이미 눈치채고 있을 것이다. 하지만 Esc 에 손가락을 올리는것은 Home row 에서 손가락이 많이 벗어난다는 것을 의미한다. 그래서 대안으로 Esc 를 대신할 수 있는 조합키가 존재한다. `Ctrl + [` 로 esc 대신 Normal Mode 로 빠져나갈 수 있다.

----------

이번에는 Vim 에서 Insert Mode 로 진입하는 다양한 방법들을 알아보았다. 가끔 vim 을 쓰는 사람이라면, i 키만 알아두어도 충분할 것이다. 하지만, 코딩을 하다보면, 위에서 소개한 모든 방법들을 사용해야하는 적절한 상황들을 분명히 만나게 될 것이다.

다음번에는 Vim 의 Normal Mode 에서의 주요한 커맨드(명령)와 오퍼레이터들을 알아보도록 하자.

# [[The Vim Way] 05 Vim 기본조작 - Vim 수정, 삭제 그리고 오퍼레이터](https://coldmater.tistory.com/217)

-   coldMater
-   [개발도구 / vim](https://coldmater.tistory.com/category/%EA%B0%9C%EB%B0%9C%EB%8F%84%EA%B5%AC/vim)
-   2021. 11. 13.

## Normal Mode 오퍼레이터(모션 지정 명령)에 대한 이해

앞서  [Vim Normal Mode 에서 커서를 이동시키는 방법](https://coldmater.tistory.com/211)과,  [Vim Insert Mode 로 진입하는 방법](https://coldmater.tistory.com/213)을 알아보았다. 이번에는 Normal Mode 의 기본 명령들에 대해서 알아보도록 한다.

> 💡 이번 포스팅은 다분히 이론적일 수 있다. 하지만, Normal Mode 에서 명령어가 동작하는 원리를 이해하고 나면 훨씬 자유롭게 해당 명령어들을 응용할 수 있을 것이다.  **이 포스팅이 [The Vim Way] 연재 중 가장 어려운 부분일 수 있지만, 당장은 본 포스팅의 스크린샷만 훑어보도록 하자.**  구미가 당긴다면, 어렵더라도 꼭 이해하고 넘어가보도록 하자.

이 포스팅을 이해하고 나면 다음 명령어들을 활용할 수 있게 된다.

-   c - 모션을 활용하여 지정한 영역을 삭제하고 Insert Mode 로 진입
-   d - 모션을 활용하여 지정한 영역을 삭제

## Vim 명령를 구분하는 기준

Vim Normal Mode 에서는 문서를 편집(문서의 내용을 변경)하기에 용이한 수정용 커맨드들을 제공한다. 이러한 수정용 커맨드들은 의미상 동일한 기능을 수행하면서도, 그 동작의 방법에 따라 크게 세 가지 기준으로 나눌 수 있다. 일단 그 기준들은 다음과 같다.

-   키를 누르는 즉시 수행되는지 - 모션 비지정형 커맨드(cf. 모션 지정형 커맨드 a.k.a. 오퍼레이터)
-   특정 동작 후 insert 모드로 진입하는지 - 문자열 입력형 커맨드(cf. 문자열 비입력형 커맨드)

이 기준에 따라 명령어를 분류해두면, 동작방식이 서로 비슷하기 때문에 쉽게 기억할 수 있다. 아래서 각 기준을 상세히 설명한다.

## 모션 지정 여부에 따른 명령어 구분

첫번째 기준인 '키를 누르는 즉시 수행되는지'라는 기준은 그 커맨드가 키 입력 이후에 추가적으로 명령을 수행할 대상을 지정해야하는 커맨드인지 아닌지를 구분한다. 뒤에서 상술하겠지만, d 와 x 커맨드 모두 삭제라는 맥락상 동일한 명령을 수행하는데, x 는 '대상 비지정형 커맨드'이고, d 는 '오퍼레이터(대상 지정형 커맨드)'이다. 이 포스팅에서 사용할 용어인 '모션'은  [Vim Normal Mode 에서 커서를 이동시키는 방법](https://coldmater.tistory.com/211)  에서 살펴본 대부분의 커서 이동법을 포함하는 vim 의 대상 지정 방법을 의미한다.

이렇게 분류되는 일련의 '오퍼레이터'들은 사실 간단하게 요약이 가능하다. 문장의 구조를 가져야 하기에  **단일 키 입력 단독으로는 수행될 수 없는 명령들**을 의미한다.

이후 포스팅에서 더 자세히 설명하겠지만, 먼저 삭제를 담당하는 명령어(x 와 d)를 가지고 오퍼레이터(대상 지정형 명령)과 비지정형 명령어가 동작하는 방식의 차이점을 살펴보자.

> 💡 이 포스팅에서만큼은, 용어 '**오퍼레이터**'의 모호한 의미를 명확하게 하기 위한 목적으로 '**오퍼레이터(대상 지정형 명령)**'으로 표현합니다. 이후 포스팅에서는 '**오퍼레이터**'라는 용어만을 사용하도록 합니다.

### 모션 비지정형 명령어 동작 방식: Command

x 명령어를 통해서 대상 비지정형 명령어가 동작하는 방식을 확인해보자. 대상 비지정형 명령어는 다음 스크린샷으로 어렵지 않게 그 동작을 확인할 수 있다.

-   명령어를 입력(x)한 순간 문서에 변화가 생겼으며
-   여전히 Normal Mode 이다. (이는 곧바로 다른 명령의 입력을 대기하는 상태임)

이렇게 보면 Vim 을 사용하지 않는 일반 텍스트 편집 환경에서의 Delete 키와 별다를게 없어 보인다. 하지만 엄밀히 Normal Mode 에서 수행한 d 커맨드와 Insert Mode 에서 delete 키로 문자를 삭제하는 vim 의 관점에서는 분명한 차이가 있다. 이에 관련해서는 추후 'vim 에서의 명령 블록' 부분에서 자세히 알아본다.

![](https://blog.kakaocdn.net/dn/c2BaRt/btrkHEqyB4B/eAskVr8mqttaJbaa4U3nyk/img.gif)

vim 에서 한 글자 삭제하기 - x 는 누르는 즉시 커서 위치의 문자가 삭제된다. 추가적인 대상 지정이 필요하지 않다.

이와 같이 단일 키로 동작하는 명령어로는 s, c, r 정도가 되겠다. 각각 명령어들의 동작들이 특징을 갖고 있지만, 이는 추후 포스팅에서 다시 자세히 다루도록 한다.

> 💡 Vim 의 세계(생태계)에서는 이 포스팅에서 '모션 비지정형 명령'이라고 소개한 동작들을 단순히 'Command' 라고 명명하였습니다. 적어도 Vim 에서는 '명령'이란 해당 키 단독으로 동작하는 기능을 의미합니다.

### 모션 지정형 명령어 동작 방식: Operator

오퍼레이터(모션 지정형 명령어)의 대표로 d 커맨드를 살펴보자. normal mode 에서 d 를 입력하게 되면 하단 status bar 에 d 가 표시된다. 이는 vim 이 motion 을 대기하고 있음을 나타낸다. 그 다음 motion 으로 지정되지 않은 키, 가령 v 를 눌러보면 경고음과 함께 명령이 취소된다. 이로써 vim Normal Mode 에서는 d 입력 이후에 motion 이 입력되기를 기대하고 있고, 그 motion 은 한정되어있음을 의미한다.

![](https://blog.kakaocdn.net/dn/cJBymh/btrkIinDLnt/5Vk6DiEjfj26FvYeGuWrb1/img.png)

d 명령어 이후에 해당 명령어가 작동할 범위를 지정한다.

Normal Mode 에서 d 키를 눌렀다는 것은 현재 커서가 위치한 위치에서부터 '삭제 명령을 시작'함을 vim 에게 알리는 것이다. 그럼 vim 은 해당 삭제 명령이 어디까지 적용될 것인지를 대기하고 있는 상태가 된다. 이 적용될 대상이 위 스크린샷에서처럼 Motion 에 해당한다. Motion 은 Normal Mode 에서의 이동 명령을 포함한다.

기본적인 vim 의 이동방법이었던 h, j, k, l 은 motion 이 될 수 있다. 가령 dh 라는 명령은 '현재 커서의 왼쪽 문자(h)를 삭제(d)'라는 뜻이 된다. 같은 원리로 dj 라는 명령은 '현재 커서부터 아래 줄(j)을 삭제(d') 라는 명령이 된다. 영문법 순서대로 V+O(동사 이후 목적어) 형태로 이해할 수 있다.

![](https://blog.kakaocdn.net/dn/bzf2b9/btrkJ8dc87O/ETyeHPSTcwjhBpulBsfx2k/img.gif)

d 키와 motion(h, j, k, l) 과의 조합

motion 은  [Vim Normal Mode 에서 커서를 이동시키는 방법](https://coldmater.tistory.com/211)  에서 알아보았던 대부분의 커서 이동법을 의미한다. 마찬가지로 dw, de, db, dW, dE, dB 와 같이 이동 방법들과 조합하여 사용할 수 있다.

> 💡 dd 명령어로 한 줄 전체를 삭제할 수 있습니다. dd 명령에서 d 이후에 오는 d 는 모션은 아니지만, 연속된 dd 입력은 '한 줄 삭제'를 수행하도록 약속되어있습니다.

### Vim Extra Motion - i & a

> 💡  **VERY IMPORTANT!**  Vim 을 택스트에디터계의 혁명이라고 부른다면, 바로 이 기능 때문이라고 생각합니다. 명령어가 동작할 대상을 정확하게 보다 정확히 타겟팅 할 수 있습니다. 무엇보다 매우 '프로그래밍적'인데 프로그래머들에게는 매우 유용한데, 프로그래머들은 괄호나 따옴표를 사용하여 코드를 묶는 일이 많기 때문입니다. 괄호 안 또는 괄호를 대상으로 할 수 있는 명령을 수행할 수 있습니다.

상술했듯,  [Vim Normal Mode 에서 커서를 이동시키는 방법](https://coldmater.tistory.com/211)에서 소개한 컨트롤 조합키를 제외한(^B, ^F, ^U, ^D - ^는 ctrl 을 의미) 모든 커서 이동법이 Motion 에 포함된다. 이 모션들만으로는 동작할 수 없는 특별한 동작들을 위해 다음 모션들을 vim 은 추가로 지원한다. 단, 여기서 소개하는 모션은 특정 명령키 이후에만 동작한다.

#### Extra Motion 의 필요성 느껴보기

가령 다음과 같은 상황을 상상해보자. 다음 스크린샷처럼 animals 의 가운데 a 에 커서가 위치해 있는 상태에서 animals 를 지우고 싶다. 어떻게 할 수 있을까? 스크린샷처럼 커서를 단어의 맨 앞으로 이동한 뒤 dw (다음 단어 삭제) 를 입력했다. 해보면 알겠지만, 가운데 a 위치에서 dw 를 하면 anim(als) 의 괄호친 부분만 삭제되고, anim 부분만 남는다. 이 때 커서가 위치한 단어를 d 할 수 있는 방법이 있다. 다음 'i - in 모션' 을 보자

# [[The Vim Way] 06 Vim 기본조작 - Vim 복사하기와 붙여넣기 그리고 레지스터](https://coldmater.tistory.com/218)

-   coldMater
-   [개발도구 / vim](https://coldmater.tistory.com/category/%EA%B0%9C%EB%B0%9C%EB%8F%84%EA%B5%AC/vim)
-   2021. 11. 14.

![](https://blog.kakaocdn.net/dn/c9dFwv/btrkSNTMKC9/cQ812aXKSbPjucFOmSj9Y0/img.jpg)

Ctrl + C, Ctrl + V 의 아버지 래리 테슬러 (1945 ~ 2020), 1970 중반에 복붙 단축키 발명

컴퓨터의 세계에서 Copy & Paste 의 개념만큼 대중적인 것도 없을테다. ctrl + c, ctrl + v 는 마치 대명사처럼 우리에게 흔한 일상이 되어버렸다. copy & paste 라는 개념이 래리 테슬러가 1973~1976 년 무렵에 발명했고, 이게 유명해진게 1978년 발매된 WordPerfect덕분이라고 한다([참조](https://unicheck.com/blog/who-invented-copy-and-paste), 글에서 소개한 WordStar 는 복붙이 다른키인듯 하다). , Vim 의 아버지격인 Vi 에디터가 1976 년에 개발되었기에, ctrl + c, ctrl + v 를 활용한 복붙 개념이 대중화되지 않은 시점이라 왜 vi 에디터에서 ctrl + c, ctrl + v 가 복사&붙여넣기가 아닌지는 이해가 된다.

![](https://blog.kakaocdn.net/dn/bEVO6e/btrkG2yVv3c/UG86LYlt0r4qJZ2NwnLoVK/img.png)

&amp;nbsp;WordPerfect 6.0 on DOS - https://www.youtube.com/watch?v=ML_GoEUhs4A 에서 캡쳐(3분 50초경)

아무튼, 궁금하지 않았을지도 모르지만  왜 vi 의 복사 붙여넣기는  괴상하고 이상하고  다른건지 알아보았다.

## Vim 에서의 복사와 붙여넣기

### y - Vim 모션 명령으로 복사하기

-   y + {모션} 명령어로 복사하여 레지스터(라고 불리는 공간)에 저장한다.

y 는 복사하기 명령이다. Vim Normal Mode 에서 y 를 누르면 vim 은 다음 모션이 무엇인지 대기한다. 앞선 포스팅에서 살펴본 motion 들을 입력하여 복사를 수행할 수 있다.

y 는 yank 의 첫글자인데, pull 과 동의어이다. 해당 부분을 '뜯어내어' 어딘가에 저장해두기 때문에 이런 용어를 사용했을 것 같다.

### Y - Vim 한 줄 복사하기

-   Y(shift + y) 명령어로 현재 라인을 복사하여 레지스터(라고 불리는 공간)에 저장한다.
-   yy 명령어로 현재 라인을 복사하여 레지스터(라고 불리는 공간)에 저장한다.(Y 와 동일)

현재 커서가 위치한 라인 전체를 복사한다.

### p - Vim 복사한 내용 붙여넣기

-   p - 현재 커서 다음에 복사된 내용을 붙여넣는다.
    -   복사된 단어들은 커서 오른쪽에 붙여넣어진다.
    -   복사된 문장들은 커서 아래줄에 붙여넣어진다.

p는 간단히 put 의 첫글자이다.

Vim 에서는 복사한 대상에 따라 붙여넣어지는 위치가 다르다. 줄 단위로 복사한 경우 커서의 아래줄에 붙여넣어지고, 단어들을 복사한 경우 커서 오른쪽에 복사한 내용이 붙여넣어진다. 이는 스크린샷을 통해 자세히 확인하자.

![](https://blog.kakaocdn.net/dn/t38a4/btrkOlcrWP5/QjII1lDmMbJhVCHlvGeQ11/img.gif)

Vim 단어 복사(yiw)하여 커서 오른쪽에 붙여넣기(p)

![](https://blog.kakaocdn.net/dn/bGgh4P/btrkIiOTcsg/u6ZLgoxq5lv9b5y4jLCyTK/img.gif)

줄 복사(yy 또는 Y)하여 커서 아래에 붙여넣기(p)

### P - Vim 복사한 내용 이전에 붙여넣기

-   P(shift + p) - 현재 커서 이전에 복사된 내용을 붙여넣는다.
    -   복사된 단어들은 커서 왼쪽에 붙여넣어진다.
    -   복사된 문장들은 커서 윗줄에 붙여넣어진다.

p(붙여넣기)와 반대 방향에 해당하는 부분에 붙여넣어진다. 스크린샷을 보도록 하자.

![](https://blog.kakaocdn.net/dn/bxcoc8/btrkJnhNvar/3Ndgz8n90ibX6GJTd3uZi0/img.gif)

괄호 안의 내용을 복사하여 P(shift + p) 기능을 이용하여 커서 왼쪽에 붙여넣기를 수행했다.

![](https://blog.kakaocdn.net/dn/bAUyyJ/btrkIQq1Bd0/YCA3AhAP1XHcKwInIzKgU1/img.gif)

한 줄을 복사하여 특정 라인에서 P(shift + p) 기능을 이용하여 줄 위에 붙여넣기를 수행했다.

## (심화) Vim 복사와 레지스터

이 부분부터는 심화된 내용으로, [The Vim Way] 여정을 마친 후에 다시 돌아와서 봐도 되는 내용이다. 다만, vim 의 복사가 정확히 어떻게 동작하는지 이해하고, 사용하고 싶다면 한번쯤 읽고 가도 좋다. (추후에 이 챕터는 별도의 포스팅으로 분리될 수도 있습니다.)

### 붙여넣는 진짜 대상

p 는 사실, 일반적인 복사-붙여넣기의 '붙여넣기'와는 그 기능이 조금 다르다. 물론 y 명령어로 수행되어 레지스터에 저장된 데이터를 붙여넣어주는 의미는 동일하지만, p 는 그 이상의 의미를 갖는다.

다음 스크린샷을 보면 알 수 있듯이, yy 를 통해 복사한 내용이 붙여넣어지는 것이 아니라, dd 를 통해 삭제된 내용이 붙여넣어지는 것을 확인할 수 있다. 즉, p 에 의해 붙여넣어지는 것은 '특정 공간에 저장된 데이터'인 것이다.

이 '특정 공간'은 '이름없는 레지스터'이다. 실제로 이름이 저렇다. 영어로는 unnamed register.

복사를 한 데이터도 '이름없는 레지스터'에 저장되고, 삭제가 수행된 데이터도 '이름없는 레지스터'에 저장된다. 따라서 복사가 된 이후에 삭제를 해버렸기 때문에 삭제된 데이터가 '이름없는 레지스터'에 저장되어 최종적으로 붙여넣기를 수행할 때, 삭제했던 데이터가 붙여넣어지는 것이다.

## [[The Vim Way] 07 Vim 기본조작 - Vim Visual Mode(블록 씌우기)](https://coldmater.tistory.com/216)

-   coldMater
-   [개발도구 / vim](https://coldmater.tistory.com/category/%EA%B0%9C%EB%B0%9C%EB%8F%84%EA%B5%AC/vim)
-   2021. 11. 14.

## Vim Visual Mode

Vim 에서 블록을 씌우고 싶을 때 사용하는 것이 Visual Mode 이다. Visual Mode 를 활용하면 다음 스크린샷과 같이, 텍스트에 블록을 씌울 수 있다.

![](https://blog.kakaocdn.net/dn/OuMqy/btrkHbJnB7v/WiC17dx4QdCaXzmUoZkKw0/img.gif)

Vim Visual Mode 에 접근하는 다양한 방법들

이렇게 Visual Mode 로 블록을 씌운 뒤 특정 명령어를 통해 해당 문자열들을 컨트롤 할 수 있다.

블록을 씌운 뒤 해당 부분을 복사, 지우기, 대체하기 등 다양한 동작을 수행할 수 있는데, 이후에 배울 명령어들과 조합하면 사실상 수행할 수 있는 동작은 수백가지(어쩌면 수천가지)에 이를 수도 있겠다.

Vim Visual Mode 는 다른 동작들과 조합되어 사용되는 경우가 많기에, 이 포스팅에서 소개한 Visual Mode 의 사용법은 한정적인 것임을 인지하고, 추후에 Vim Visual Mode 와 함께 다양한 조합을 따로 다뤄보도록 하겠다.

## Vim Visual Mode 진입하기

Normal Mode 에서 Vim Visual Mode 모드에 진입하는 방법은 다음과 같이 크게 3가지가 있다.

### v - 문자 단위 Vim Visual Mode 진입

-   v 키 누른 뒤, 커서 이동 명령으로 블록 범위 지정

Normal Mode 에서 Vim Visual Mode 모드에 진입하는 첫번째 방법이다. 이 방법으로 문자단위의 블록을 씌울 수 있다. 다만 인지해야할 것이 하나 있는데, visual 모드로 진입한 이후의 동작은 대부분 Normal Mode 와 비슷하다. 블록을 씌울 수 있고, 해당 블록에 대해 특정 명령어를 수행할 수 있다.

일단 블록을 씌워보도록 하자. v 키를 누른 뒤, 이동 명령을 활용하여 블록을 이동시킬 수 있다.

![](https://blog.kakaocdn.net/dn/BWDVj/btrkSOd3ocC/qVPkmNoSKNABKEVMVXytck/img.gif)

vim visual mode, v 키를 활용한 기본 visual mode 로의 진입 - v 키 이후 커서 이동 명령을 활용하여 블록 범위를 지정할 수 있다.

#### 모션과의 조합으로 visual mode 진입

먼저 인지할 것은, v 명령은 앞선 포스팅 [[The Vim Way] 05 Vim 기본조작 - Normal Mode 오퍼레이터(모션 지정 명령)에 대한 이해](https://coldmater.tistory.com/217)에서 다룬 '오퍼레이터(모션 지정형 명령)'으로도 사용할 수 있다는 점이다. 바로 위에서 블록 범위를 컨트롤 하는데 활용한 이동명령 또한 일종의 모션이었음을 기억하자. 다음 스크린샷처럼, v + {모션} 명령으로 블록을 다양하게 선택할 수 있다. 물론 블록이 설정된 이후에 visual mode 인 상태로 커서 이동은 여전히 유효하다.

![](https://blog.kakaocdn.net/dn/bMgYCO/btrkIgQHhSO/RofOGRL1Iid7wWbIuz4JdK/img.gif)

### V - 줄 단위 Vim Visual Line Mode 진입

-   V(shift + v) 키 누른 뒤, 커서 이동 명령으로 블록 범위 지정

![](https://blog.kakaocdn.net/dn/bSeKE2/btrkJ7yXrEY/pujlQLQEoRz0BaKpUkOitk/img.gif)

vim visual mode, V 키를 활용한 visual line 모드로 진입 - 이후 기본 이동 명령을 활용하여 블록 범위를 지정할 수 있다.

블록을 라인 단위로 설정한다. 특별한 점은, Visual Line 모드를 시작한 위치부터 커서가 위치한 부분까지 '줄 단위'로 영역이 설정된다는 점이다. 보통 j, k 와의 조합으로 많이 사용하게 된다.

### ^v - Visual Block Mode 진입

^v(Ctrl + v) 명령으로 Visual Block Mode 에 진입할 수 있다. 이는 다음 스크린샷과 같이, 대상을 조금 특이하게(?) 지정할 수 있다. 마치 GUI 환경에서 대상을 드래그로 지정하는 것과 비슷한 느낌이다. 일단 스크린샷을 보자.

![](https://blog.kakaocdn.net/dn/dvUK2e/btrkHLqbxWU/IhBbwapo5C0uZKdyS7fP70/img.gif)

vim visual block mode - 사각형 단위로 문서를 선택할 수 있는 기능

Visual Block Mode 는 위와 같이 텍스트에디터(위 스크린샷은 VSCode)나 IDE 에 따라 Multi Cursort 에 대응되는 기능이다. 따라서, IDE 나 텍스트에디터에 따라서 그 동작이 조금씩 다를 수도 있다. 아래 스크린샷처럼 실제 vim 의 visual mode 에서는 블록을 씌운 뒤 변경 명령(s)을 내렸을 때 마치 첫 번째 줄만 수정되는 것처럼 보이다가 esc 로 빠져나오면 블록으로 지정한 전체 범위에 대하여 변경이 적용되어있음을 확인할 수 있다.

![](https://blog.kakaocdn.net/dn/yyeYm/btrkHoaUAY5/NXQ0f9Ry3aC45hHVT1fPh1/img.gif)

실제 vim 에서 visual block mode 가 동작하는 방식

vim visual block 모드는 위처럼 좌우 폭이 정형화된 데이터를 다룰 때 굉장히 유용하다. 그러나, 명확히 한계도 존재하는데, 서로 다른 폭을 지정하는 데에는 적절하지 않다는 것이다. 가령 아래 스크린샷과 같은 데이터 구조를 예로 들 수 있다. 모든 변수의 타입을 일괄적으로 int 로 변경하고 싶다고 하자. (그런 언어가 없을 수도 있지만) 좌우 폭이 정형화되어있지 않기 때문에 뭔가 어색한 결과가 도출된다.

![](https://blog.kakaocdn.net/dn/o5H3i/btrkJmpHiZ8/xxGpQEDtEWGRxF0pRkRP91/img.gif)

vim visual block mode 의 한계

이런 경우 IDE 에서 자체적으로 제공하는 multi cursor 기능과 vim 기능을 조합하여 사용하는 것도 굉장히 도움이 된다. (조사해본 것은 아니지만, 기본 Vim 플러그인으로도 multi cursor 기능이 있지 않을까 짐작해본다.) 다음은 VSCode 에서의 Multi Cursor 와 Vim 을 조합하여 사용하는 예시이다.

![](https://blog.kakaocdn.net/dn/xYOrI/btrkSMN5hRW/tI2wVueLnLn6MFENwHBkWk/img.gif)

vim 의 기능과 IDE(또는 텍스트에디터)의 Multi Cursor 기능을 조합하여 사용하기

대부분의 메이저 IDE, 텍스트에디터에서는 멀티커서 기능을 지원하므로, 각 에디터의 MultiCursor 단축키를 익혀두는 것은 Vim 사용법을 익히는 것과는 별도로 유용할 수 있겠다.

사실 Visual Block 모드로의 단축키가 ctrl + v 라는 점은 윈도우 사용자에게 치명적이다. vim 을 사용하더라도 붙여넣기 기능을 사용하는 경우가 흔하기 때문이다.(ctrl + a 도 자주 사용) 그렇기에 필자는 윈도우에서는 보통 ctrl + v 를 그냥 일반적인 붙여넣기 기능으로 사용한다.

### gv - 이전 블록 영역 재선택하기

-   gv - 이전 블록 영역을 재선택할 수 있다.

블록을 씌운 뒤 escape 로 빠져나온 뒤, 이전에 선택했던 영역을 바로 다시 선택해야 하는 경우가 있다. vim 은 이전에 선택했던 영역을 그대로 기억하고 있는데, 이 기억을 기반으로 gv 명령을 통해 이전 선택 영역을 다시 선택할 수 있다.

어쨌든 Visual Mode 로 진입하는 3가지 모드와 함께, 이 방법으로도 Visual Mode 에 진입할 수 있기에 여기에 소개한다.

![](https://blog.kakaocdn.net/dn/Sk5pP/btrlwIFKSrP/H8zfsrjbKbDkXgOnl4M1Dk/img.gif)

이전 선택 영역을 바로 다시 선택하여 Visual Mode 에 진입할 수 있는 gv 명령어

## Vim Visual Mode 에서의 모드 전환

### Visual to Non-Visual

-   esc 키로 현재 블록을 취소하고 Visual Mode 에서 Normal Mode 로 전환할 수 있다.
-   특정 명령을 수행하면 블록 영역에 대해 해당 명령을 수행한 뒤, Normal Mode 또는 Insert Mode 로 전환된다.

당연한 얘기지만 굳이 Vim Visual Mode 를 빠져나가는 방법에 대한 이야기를 한번 하고 가는 이유는 다음과 같다. Visual Mode 는 어떤 명령을 수행하기 전에, 적용 대상에 블록 범위를 씌우는 동작이고, 이는 Visual Mode 가 다른 명령과 조합되어 사용되는 '보조적인 수단'으로서의 모드임을 의미한다. 따라서, 해당 명령이 적용되면, 더 이상 Visual Mode 를 유지하지 않고, Normal Mode 로 빠져나가게 된다.

가령 다음 스크린샷과 같이, Visual Mode 로 진입하여 블록을 씌운 뒤 d 키를 누르면 해당 부분이 삭제되고 Normal Mode 로 전환된 것을 확인할 수 있다.

![](https://blog.kakaocdn.net/dn/bcCWkb/btrkJ5VuAnZ/WQ03n3q0K9Tb5Bqq9NsXRK/img.gif)

visual mode 에서 특정 동작을 수행 한 뒤, vim mode 가 변경되는 모습

또한 visual mode 에서 s 키를 누른다는 것은 s 의 의미와 완벽히 동일하다. 다만, 적용 대상이 블록 지정 대상이라는 것만이 다를 뿐이다.

![](https://blog.kakaocdn.net/dn/ubbLJ/btrkJnozKfz/7smXzK80kXMG42yRiPsZe1/img.gif)

vim visual mode 에서는 어떤 명령어를 사용하느냐에 따라 진입되는 mode 가 다르다.

### Visual to Visual

Visual Mode 는 위에서 살펴본 것처럼 총 3가지이다. 기본 Visual Mode 에 더해 특수한 Visual Mode 인 Visual Line Mode와 Visual Block Mode가 그것이다. Visual Mode 간에는 서로 전환이 가능하다. Visual Mode 를 시작한 커서의 위치를 기억하고 있기 때문에, 현재 커서의 위치까지의 각 Visual Mode 의 동작원리를 기반으로 블록이 다시 세팅된다. 말이 어렵다. 다음 스크린샷을 보자.

![](https://blog.kakaocdn.net/dn/bjgLa3/btrkIj763v1/R88j133n7L2TNmhGKYDUGk/img.gif)

visual mode 간의 전환

## Visual Mode 에서 명령 수행하기

Visual Mode 에서 수행할 수 있는 명령은 크게 다음과 같다.

-   지정한 영역 삭제하기
-   지정한 영역 삭제하고 입력 시작하기 (Insert Mode로 진입)
-   지정한 영역 복사하기

### 지정한 영역 삭제하기

Visual Mode 에서 허용되는 삭제 명령은 다음과 같다.

-   D - Visual Block Mode 에서는현재 커서의 오른쪽 영역만 삭제
-   d, D, x, X - 모두 동일한 동작을 기대할 수 있다.(= 한 가지만 기억하고 사용해도 충분하다.)

이 삭제 명령들이 3가지 Visual Mode에서 각각 어떻게 작동하는지는 직접 확인해보도록 하자.

### 지정한 영역 삭제하고 입력 시작하기

-   C - Visual Block Mode 에서는현재 커서의 오른쪽 영역만 삭제하고 Insert Mode 로 진입
-   s, S, c, C - 모두 동일한 동작을 기대할 수 있다.(= 한 가지만 기억하고 사용해도 충분하다.)

필자가 자주 사용하는 삭제 명령어는 c 이다. (사실, 이 외에 다른 삭제 후 입력 커맨드는 덜 유용하다.)

### 지정한 영역 복사하기

-   y

y 는 앞선 포스팅에서 살펴보았던 것처럼, 오퍼레이터(모션 지정형 명령)이다. 그렇기에 모션을 지정하여 복사할 수도 있지만, 필자는 아무래도 복사되는 영역이 가시적으로 보이는 것을 선호하기 때문에 visual mode 로 복사할 영역을 지정한 후 y 키를 눌러 복사하는 경우가 많다.

앞서 Multi Cursor 를 언급한 것처럼, Visual Block 모드에서 복사하여 붙여넣기의 동작은 IDE 마다 그리고 순정 Vim 에서의 동작과 다를 수 있음에 유의한다.

또한 주의할 점은, 앞선 포스팅에서 언급했던 것처럼, Vim 에서 클립보드에는 직접 복사한 영역 외에도, 최근에 삭제된 내용이 들어간다는 점을 기억하자.

### 시작커서 현재커서 전환

-   o 키로 visual mode 를 시작한 커서의 위치와 현재 커서의 위치를 변경할 수 있다.

Vim Visual Mode 에서는 Visual Mode 를 시작한 커서의 위치를 기억하고 있다고 했다. o 키를 눌러 시작 커서와 현재 커서를 서로 전환할 수 있다. 문장으로 보면 이게 왜 필요한지 감이 잘 안 올 수 있겠다. 이를 활용하면 블록 영역을 더욱 스마트하게 확장할 수 있다. 다음처럼 "goats", "sheep" 이 선택되어있는 상태에서 "pigs" 까지 선택하고 싶을 수가 있다. 물론 다시 블록을 푸는 방법도 있겠지만, 현재 블록을 유지한 채로 시작커서와 현재커서를 전환하여 시작커서 위치에서 블록을 확장시켰다.

![](https://blog.kakaocdn.net/dn/BFSlK/btrkQkRQ0do/40uXJAV7iiiojAVcNNTDGk/img.gif)

visual mode 에서 o 키를 활용하여 시작 커서 위치와 현재 커서 위치를 변경했다. 이제 변경된 커서 위치로부터 블록 영역이 확장된다.

이번 예제는 그다지 유용하지 않았을 수 있지만, 아주 긴 줄을 Visual Line Mode 로 선택해두었다고 상상해보자. 블록 영역은 스크롤을 해야할 정도로 길다고 상상해보자. 그런데 처음 줄보다 몇줄 더 선택하고 싶어질 수 있다. 아래와 같이 시작 커서와 현재 커서를 전환하여 보다 스마트하게 블록 영역을 확장할 수 있다.

![](https://blog.kakaocdn.net/dn/MQwDD/btrkOk5FTxZ/45aNiQKlYuGDM7gAeZykl0/img.gif)

visual mode 에서 o 키를 활용하여 시작, 끝 영역을 전환할 수 있고, 블록의 시작 부분에서도 블록 영역 확장을 할 수 있다.

----------

이상으로 Vim 에서 문서의 일부에 블록을 씌울 수 있는 모드인 Vim Visual Mode 에 관해서 알아보았다. 사실 Visual Block Mode 는 차치하고서라도, 일반 visual mode 와 visual line mode 는 정말 자주 사용하는 모드이므로 꼭 익혀두도록 하자. 여기까지 차근차근 연습해왔다면, 배웠던 기능들을 조합하여 점점 이렇게 저렇게 응용할 수 있는 방법들이 떠오르기 시작할 것이다. 이제 앞으로 남은 몇 가지 추가 기능들만 숙지하면, 진정한 Vim Way 를 걷게 될 능력을 갖추게 되는 것이다.

다음 포스팅에서는, 지정한 대상으로 커서를 이동하는 방법을 알아본다.


# [[The Vim Way] 08 Vim 기본조작 - Vim 특정 문자로 커서 이동](https://coldmater.tistory.com/219)

-   coldMater
-   [개발도구 / vim](https://coldmater.tistory.com/category/%EA%B0%9C%EB%B0%9C%EB%8F%84%EA%B5%AC/vim)
-   2021. 11. 19.

## Vim 특정 문자로 커서 이동하기

이번에는  `f`,  `F`, 't', T' 키를 활용해서 한 줄 안에서 특정(지정한) 키로 이동할 수 있는 방법을 알아본다. 앞서 살펴보았듯, 문자 단위로 한 글자씩 좌, 우로 이동할 수 있었는데  `h`,  `l`  로 가능했다. 단어 단위로 점프하고자 할 때는  `w`,  `W`,  `b`,  `B`,  `e`,  `E`  등을 활용했다. 그러나 때로는 단어 단위가 아니라 '특정 문자까지'를 명령의 대상으로 삼고싶을 때가 있다. 다음 코드를 보자.

```
Calculator c2 = new CalculatorDecoMinus(); // 주석만 남기고 싶다면?
↑ 커서는 C 위치에 있다고 가정
```

현재 커서가 맨 첫번째 문자 - C 에 있다고 가정하자. 이 때, 주석만 남기고자 한다면 어떻게 할 수 있을까? 한번 생각해보자. 다양한 답이 나올 수 있다. vim 고수라면, 여러가지 방법들이 생각해낼 수 있을 것이다. '특정 문자로 커서 이동하기' 기능을 활용하면 단 한번의 명령 -  `dt/`로 해결할 수 있다. (미리 명령어를 풀어 설명하자면, '지워라(d) "/" 문자 까지(t)' 로 해석할 수 있다.)

![](https://blog.kakaocdn.net/dn/bC7STH/btrlykqjoSY/EWh5NpD3kjdVzfUk5DdjU0/img.gif)

vim 에서 특정 문자로 이동하는 모션을 활용하여 커서를 한번에 해당 문자로 이동시킬 수 있다.

### `f`,  `t`  - 지정 문자까지 앞으로 이동하기

-   `f`  명령어는 지정한 문자가 존재하는 위치로 이동한다.
-   `t`  명령어는 지정한 문자 바로 직전 위치로 이동한다.

다음 스크린샷과 같이  `f`  명령어는 지정한 문자 직전 문자로 이동한다. 반면  `t`  명령어는 해당 문자 직전 문자까지 이동한다.  `t`  는 till 의 앞글자를 의미하는데, '~까지'라는 의미를 담고 있다. 따라서 '지정 문자 직전까지'라고 이해하면 기억하기 쉽다.  `f`  는 find 의 앞글자를 따온 것 같다. 실제로 해당 문자를 찾겠다라는 의미로 이해하면 되겠다.

![](https://blog.kakaocdn.net/dn/bIzxzG/btrlqBG1JAe/cKJSQN64ChLJfBkFairQfk/img.gif)

f 와 t 명령어의 차이

### `F`,  `T`  - 지정 문자까지 뒤로 이동하기

-   `F`(shift + f) 명령어는 지정한 문자의 위치로 뒤로 이동한다.
-   `T`(shift + T) 명령어는 지정한 문자 바로 직전 위치로 뒤로 이동한다.

`f`,  `t`  와 동일한 원리로 거꾸로 이동할 뿐이다. 커서로부터 전에 있는 문자를 찾는다.


# [[The Vim Way] 09 Vim 기본조작 - Vim 문자열 찾기](https://coldmater.tistory.com/221)

-   coldMater
-   [개발도구 / vim](https://coldmater.tistory.com/category/%EA%B0%9C%EB%B0%9C%EB%8F%84%EA%B5%AC/vim)
-   2021. 11. 19.

현대 텍스트 에디터는 모두 찾기 기능을 갖고 있다. 윈도우 기준으로 보통 F3 이나, Ctrl + F 로 찾을 수 있고, 바꾸기는 Ctrl + R 단축키로 대부분 실행된다. Vim 에서도 찾기 기능을 제공한다.

## Vim 문자열 찾기

vim 에서 문자열을 찾는 방법은 2가지다. 커서 다음 부분을 찾아갈지, 커서 이전 부분을 찾아갈지에 따라 두 가지로 나뉜다.

### `/`  - 다음 문자열 찾기

-   `/{찾을 문자열}`  -  `/`  키 입력 후 '찾을 문자열'을 입력하여 현재 커서  **다음**에 나타나는 '찾을 문자열'로 커서를 이동시킬 수 있다.

Normal 모드에서  `/`  를 입력하면 하단 Status Bar 에 그대로  `/`  가 표시되는 것을 확인할 수 있다. 이 때, 찾기를 원하는 문자열을 써 넣으면 된다. 찾기를 수행하면 에디터는 해당 문자열을 하이라이트 해준다.

![](https://blog.kakaocdn.net/dn/OPxaw/btrlAsg0stE/Is6zNxkVUfeKI0oUOUwkr0/img.gif)

vim 에서 찾기, / 키를 활용한다. 찾기 동작을 수행하면 해당 문자열로 커서가 이동한다.

### `n`  - 다음 찾기 대상으로 커서 이동

-   `n`  - 찾기(`/`) 명령 수행 후 동일한 다음 찾기 대상으로 이동할 수 있다.

`/`  명령어를 수행하여 찾기를 진행했다면, 이제  `n`  키를 눌러 다음 찾기 대상으로 이동할 수 있다.

![](https://blog.kakaocdn.net/dn/DOiFL/btrlzNewDGp/V6DQUO6hifcOYkf6cWyBC1/img.gif)

Vim 찾기(/) 를 수행했다면, n 키를 활용하여 다음 찾기 대상으로 이동할 수 있다.

### `N`  - 다음 찾기 대상으로 커서 이동

-   `N`(shift + n) - 찾기(`/`) 명령 수행 후 동일한 이전 찾기 대상으로 이동할 수 있다.

`N`  명령어는  `n`  명령어와 반대되는 방향으로 커서를 이동시켜준다.

![](https://blog.kakaocdn.net/dn/bR7HtU/btrlvBGSNns/0RG2b5nIKEQH8CKkKCp0I1/img.gif)

Vim 찾기(/) 를 수행했다면, N(shift + n) 키를 활용하여 이전 찾기 대상으로 이동할 수 있다.

### `?`  - 이전 문자열 찾기

-   `?{찾을 문자열}`  -  `?`  키 입력 후 '찾을 문자열'을 입력하여 현재 커서  **이전**에 나타나는 '찾을 문자열'로 커서를 이동시킬 수 있다.

이는  `/`  명령어와 탐색 순서가 반대이다. 즉, 현재 커서 이전의 부분부터 '찾을 문자열'을 탐색한다. 굳이 왜 이게 있는지 궁금하기도 하겠지만, 수십만 라인이 쌓여있는 로그에서 최근에 쌓인 로그는 보통 맨 아래에 있다. 이를 '찾기'를 이용해서 찾을 때 첫번째 줄부터 찾고자 하는 문자열을 탐색하는 것보다, 마지막 줄로 이동하여 이전에 나타나는 최초의 문자열을 찾는 것이 빠르다.

`n`  키는 찾기를  `/`  로 했는지  `?`  로 했는지에 따라 그 방향이 달라진다.  `n`  키는 '찾기가 탐색하는 방향'을 그대로 따라간다. 따라서  `?`  키로 찾기를 했을 때  `n`  키의 탐색 방향도 '이전 방향'이다. 마찬가지로 이 상황에서  `N`  키는 '다음 방향'을 의미한다.


# [[The Vim Way] 10 Vim 기본조작 - Vim 이전 명령 재실행(마이크로 매크로)](https://coldmater.tistory.com/220)

-   coldMater
-   [개발도구 / vim](https://coldmater.tistory.com/category/%EA%B0%9C%EB%B0%9C%EB%8F%84%EA%B5%AC/vim)
-   2021. 11. 19.

## Vim Micro Macro

Vim Normal Mode 에서 이동 명령을 제외한 대부분의 명령은 하나의 '명령 블록'이다. 이 '명령 블록'은 재실행이 가능하다. 이전에 수행한 명령을 그 즉시 반복하고자 할 때, Micro Macro 를 활용하면, 키 입력 하나로 그 명령을 반복할 수 있다.  **Micro Macro 는 Normal Mode 에서  `.`키를 입력하는것으로 수행이 가능하다.**

이전에 무엇을 행했듯, 그것은 Vim 에게 하나의 명령이고, 그 명령을 그대로 재실행하는 것이 Vim Micro Macro - Vim 마이크로 매크로다.

사실 거의 모든 명령에 대해 Micro Macro(Vim 점 명령어) 가 적용되기 때문에, 모든 예시를 다루기는 어렵고(사실 불가능하고) 여기서는 몇가지 코딩에 도움이 될만한 상황으로 Micro Macro(Vim 점 명령어) 를 알아보도록 하자.

> 💡 '마이크로 매크로'는 '매크로'와 다른 의미다. q 키로 시작하는 '매크로'는 훨씬 복잡하지만 강력한 반복 기능을 제공한다. 다만, '마이크로 매크로'는 이전 명령을 매우 간단히 반복할 수 있다는 데 의의가 있다. 이름은 '마이크로'이지만, 결코 작지 않은 기능이다.

### 예시1 - 한 줄 지우기(`dd`) 재실행

간단한 예시를 보자. 다음 코드에서 'invalid code'에 해당하는 라인만 전부 지우고 싶다고 가정하자.  `dd`  명령어를 활용할 것이다.

![](https://blog.kakaocdn.net/dn/bviDp2/btrlw3XbUw5/JXhFRn8z3ZLwULkiskbWGK/img.gif)

Vim Micro Macro, 마이크로매크로를 활용하여 이전 명령어 반복하기

맨 처음 나타난 'invalid code' 를 지울 때에만  `dd`  를 사용했고, 이후에는  `.`  만 눌러도 해당 줄이 삭제되는 것을 확인할 수 있다. vim 에게 이전에 수행한 명령어는  `dd`  이고, 이를  `.`  (Micro Macro - 마이크로 매크로)로 반복했다.

이 예제는 마이크로매크로가 작동하는 방식을 설명했을 뿐, 그다지 강력하다고 보기에는 힘들다(물론 충분히 편리하지만). 단순히  `dd`  의 2번의 키스트로크를  `.`  1번으로 줄였을 뿐이다. 다음 예시에서 더 많은 키스트로크를 줄이는 예를 살펴보자.

### 예시2 - 문자열 바꾸기(`ciw`) 재실행

다음 코드에서 나타나는 'execute' 를 'run' 으로 변경해야한다고 하자. 단, 주석에 포함되어있는 execute 는 그대로 두어야 하는 상황이라고 하자. 모든 execute 를 run 으로 바꾸어야 한다면 보통 에디터의 '찾아 바꾸기' 기능을 사용하면 그만이지만, 이 경우는, 대상의 속성에 따라서 대상을 바꾸어야 하는지 바꾸지 않아야 하는지 결정해주어야 한다. 그런 경우 이전 포스팅에서 살펴봤던 '찾기' 기능을 활용하여 다음 스크린샷과 같이 '스마트하게' 여러 문자열을 일괄적으로 변경할 수 있다. 특히, 동일한 문자열에 대해 일부는 변경해야 하는데, 일부는 그렇지 않을 때 이번 패턴이 도움이 된다.

![](https://blog.kakaocdn.net/dn/cYVBE8/btrlvBmz8PW/5quaKaZ4WlP38BM84RGKnK/img.gif)

찾기 기능(/)과 문자열바꾸기 기능(ciw) 그리고 마이크로 매크로(.)의 조합

이 때,  `ciw`  를 입력한 뒤, 새로운 문자열을 입력하고 escape(`esc`) 로 빠져나온 순간까지가 하나의 '명령 블록' 이 된다. 즉 다음 키스트로크가 통째로 하나의 '명령 블록'이다.

`[ciw + execute(문자열입력) + esc]`

총 3 + (문자열길이 7) + 1 의 총 11 개의 키스트로크를 . 하나로 재실행했다. 이를 잘 활용하면, 특히 반복되는 명령에 대해서는 극적인 생산성 향상을 이뤄낼 수 있다.

Vim 의 Micro Macro 는 이와 같은 '명령 블록' 을 단숨에 실행시킬 수 있는 마법같은 기능이다.

### 예시3 - 여러줄의 시작에 동일한 문자열 삽입

현대 IDE, 텍스트에디터는 멀티커서 기능을 지원하기에 지금 보는 기능이 그다지 신선하지 않을 수는 있다. 하지만, 이 기능을 활용하면 다양한 응용이 가능하기에 그 의의가 있다.

객체의 멤버변수들의 접근제어자를 모두 public 으로 지정하고 싶다고 하자. 다음처럼.

![](https://blog.kakaocdn.net/dn/DXvoQ/btrlvBtpKvu/K77gaRdqf51ceRZztMXik1/img.gif)

마이크로 매크로(Vim . 커맨드)를 활용한 동일 작업의 반복

(말은 안되지만) 이제 위처럼 변경된 코드 중에 int 타입과 String 타입은 모두 앞으로 사용하지 않게 되어, @Deprecated 라는 데코레이터를 붙여줘야 된다고 가정하자. 그럼 다음과 같이 마이크로 매크로를 활용할 수 있다.

![](https://blog.kakaocdn.net/dn/rud19/btrlw2YkrMe/VZ3dFXGJctkzaIYkNuIKm0/img.gif)

마이크로 매크로(Vim . 커맨드)를 활용한 동일 작업의 반복

이 외에도 응용은 무수히 많을 수 있다. 위 3가지 예시는 필자가 포스팅을 작성하면서 기억을 쥐어짜내 만들어냈기 때문에, 그다지 유용해보일 수 있지 않을지도 모르겠다. 아래 예시4부터는 필자가 실제로 코딩을 하다가 "이게 마이크로 매크로 쓰는 맛이지!!!" 라고 느끼는 순간에 돌아와 해당 상황으로 예시를 작성한 것이다.

### 예시4 - 업데이트 중

(... 실제로 코딩하다가 유용한 상황을 맞닥뜨리면 다시 와서 업데이트 하겠습니다...)

----------

간단하지만 강력했다. 앞선 포스팅들에서 살펴본 모든 기능들을 마이크로 매크로와 접목시켜보자. 무궁무진한 응용이 가능할 것이다. 이제 명령어 '반복'이 남았다. 우리가 원하는 횟수만큼 해당 명령을 반복하여 수행하게끔 할 수 있다. 다음 포스팅에서는 '명령어 반복'에 대해서 살펴본다.


# [[The Vim Way] 11 Vim 기본조작 - Vim 명령 n번 반복하기](https://coldmater.tistory.com/222)

-   coldMater
-   [개발도구 / vim](https://coldmater.tistory.com/category/%EA%B0%9C%EB%B0%9C%EB%8F%84%EA%B5%AC/vim)
-   2021. 12. 5.

## Vim n번 명령 반복하기

### Normal 모드에서 숫자를 입력한다는 것

Vim Normal Mode 에서 숫자를 입력하면 상태표시줄에 숫자가 입력되는 것을 확인할 수 있다. 이것은 이렇게 입력된 숫자 이후에 입력되는 명령이 반복될 횟수를 지시한다. 이런 방식으로 Vim 에서는 대부분의 명령어를 n회 반복할 수 있다. 명령어를 수행하기 전에 숫자를 미리 입력하고 명령을 수행하면, 해당 명령이 입력한 숫자만큼 반복되는 것이다.

### 붙여넣기 반복하기

다음 예제는 한 줄을 복사하여 13회 붙여넣는 예제이다.

붙여넣는 명령어 `p` 앞에 13을 먼저 타이핑했고, 실제로 `p` 명령어가 13회 수행되는 것을 확인할 수 있다.

![](https://blog.kakaocdn.net/dn/NxWtB/btrmZHY53Uz/o1Gdvz80xTt3E4xrOD8va0/img.gif)

yy -&amp;amp;gt; 13p, Vim 에서는 모든 명령의 앞에 반복할 횟수를 지정할 수 있다.

### 줄 삭제 반복하기

5줄을 연이어 삭제하고자 할 때는 어떻게 할지 상상해보자.

가장 직접적인 방법은 `dd` 명령어를 총 5회 입력하는 것이다. 총 10회의 키스트로크가 발생한다.

앞서 살펴본  ['Vim 의 마이크로 매크로](https://coldmater.tistory.com/220)' 를 활용하면 최초 수행시 `dd` 이후 `.` 명령어를 연이어 4회 입력할 수 있다. 총 6회의 키스트로크가 발생한다.

이 포스팅의 주인공인 '명령어 반복' 기능을 활용하면 총 3번의 키스트로크로 위와 동일한 목적을 이룰 수 있다.

다음 예제는 라인을 삭제하는 예제이다. `dd` 명령어를 총 5회 반복하기 위하여 `5dd`를 입력한다.

![](https://blog.kakaocdn.net/dn/chPgE6/btrm3QHLsfq/ajo4UklUF8pMJdVRYBhBb1/img.gif)

5dd, Vim 에서는 명령을 반복할 수 있다. 한 줄 지우기 명령을 5번 반복하게 했다.

### n번째 출현하는 문자로 이동하기

앞선 포스팅에서 우리는 한 줄에서 특정 문자로 이동하는 방법을 살펴보았다. `f`, `t` 명령어로 가능했다는 점을 기억하자. 다음 문장처럼, 동일한 문자가 여러개 나타나는 경우 명령 반복을 활용하여 단번에 해당 문자로 이동할 수 있다.

"show me the money please"라는 문장이 있다. 현재 커서는 s 에 위치하고 있다. e 는 총 5번 등장하는데, 각 위치로 단번에 이동해야할 필요성이 생길 수 있다.

앞서 살펴본것처럼`f`명령어를 이용해 `fe`로 다음 'e' 로 이동한 다음 `.` 을 입력하면 순차적으로 다음 e로 이동한다. 하지만, 때때로 '단번에 이동해야할 필요성'이 생길 수 있는데, 특히 이후에 살펴볼 '매크로'기능과 조합될 때 그 진가가 발휘된다.

여기서는 '단번에' 원하는 'e' 위치로 이동해보도록 할 것이다.

간단히, 커서를 위치시키고자 하는 n번째 e 로 이동하기 위해서 `f{n}e` 명령어를 입력해보자.


# [[The Vim Way] 12 Vim 기본조작 - Vim undo(되돌리기), redo(재실행)](https://coldmater.tistory.com/224)

-   coldMater
-   [개발도구 / vim](https://coldmater.tistory.com/category/%EA%B0%9C%EB%B0%9C%EB%8F%84%EA%B5%AC/vim)
-   2021. 12. 5.

## Vim 에서 되돌리기(undo)와 재실행(redo)

Vim 에서는 '되돌리기' 동작을 Normal Mode 의 `u` 키로 수행할 수 있다. `u`를 입력하는 순간 직전에 수행했던 명령들이 되돌려진다. 다음 스크린샷은 되돌리기 및 재실행 동작이 어떻게 수행되는지를 보여준다.

먼저 숫자 100을 200으로 바꾼 뒤, `+=` 연산자를 `-=` 으로 변경하고, sum 변수명을 total 로 변경하는 과정을 진행한 뒤, 되돌리기(`u`)와 재실행(`ctrl + r`)을 수행한 장면이다.

![](https://blog.kakaocdn.net/dn/pquNu/btrmXE3iXiv/QKn0WDzPnwBUEOqOgF17yk/img.gif)

Vim 에서의 되돌리기(u)와 재실행(ctrl + r)

## Vim 되돌리기와 명령블록

Vim 에서 되돌리기를 할 때에는 '명령 블록' 단위로 되돌리기가 수행된다는 점이 중요하다. 우리가 일반 에디터에서 Ctrl + z 로 되돌리기를 하던 것과는 그 느낌이 다르다. 이 명령블록을 이해하지 않고 Vim 을 사용하다보면, 의도치 않는 부분까지 되돌아가버리는 상황들을 자주 맞닥뜨리게 될 것이다. 다음은 명령블록을 잘못 이해한 예시이다. java의 main 함수를 작성한다고 가정했다.

![](https://blog.kakaocdn.net/dn/boILYY/btrmYF8xrZp/kLQbjqsvNwk6EFaW2tYHK0/img.gif)

insert 모드 진입 후 쉬지 않고 타이핑을 했다. i -&gt; 문자열 타이핑 -&gt; esc

자 이제, Normal Mode 에서 `u` 를 눌러보도록 한다.


# [[The Vim Way] 13 Vim 기본조작 - 기본조작편 요약 (ft. viEmu Cheat Sheet), Vim 학습 커리큘럼](https://coldmater.tistory.com/223)

-   coldMater
-   [개발도구 / vim](https://coldmater.tistory.com/category/%EA%B0%9C%EB%B0%9C%EB%8F%84%EA%B5%AC/vim)
-   2021. 12. 6.

## viEmu VIM Cheat Sheet

Vim Cheat Sheet 라고 검색해보면, 많은 자료가 나오는데, 그 중 가장 눈에 띄는것은 다음 치트시트일 것이다.

viEmu Cheat Sheet 는 키보드의 모든 키스트로크에 의미를 적어놓아, 한 눈에 Vim 의 모든 기능을 파악하기에 용이하다.

또한, 7 스테이지로 Vim 을 차근차근 학습할 수 있도록 그 중요도와 목적에 따라 기능을 구분해놓았다.

이 포스팅에서는 7개의 각 Lesson 의 주요 내용을 정리함과 동시에, 본 연재의 관련 링크를 걸어두었다.

[http://www.viemu.com/a_vi_vim_graphical_cheat_sheet_tutorial.html](http://www.viemu.com/a_vi_vim_graphical_cheat_sheet_tutorial.html)

[](http://www.viemu.com/a_vi_vim_graphical_cheat_sheet_tutorial.html)

Graphical vi-vim Cheat Sheet and Tutorial

Graphical vi-vim Cheat Sheet and Tutorial Learning vi or vim is not easy. But it doesn't have to be that difficult, either. It is, in any case, faster, more powerful, and more productive than editing with any other editor, so you would do very well in inve

www.viemu.com

![](https://blog.kakaocdn.net/dn/dkpahT/btrmXt8RVeF/QBJ0mxcgsR6yl9TrVsxpa1/img.gif)

viEmu Vim Cheat Sheet - http://www.viemu.com/a_vi_vim_graphical_cheat_sheet_tutorial.html

> 🎈 본문에서  **^ 문자는 키보드의 control**  을 의미합니다. 가령 ^R 은 Control + R 조합키를 의미합니다.

> 🎈 [The Vim Way] '기본조작'편에서 다루지 않은 내용에는  **볼드체**로 표시해두었습니다. 해당 내용들은 다루지 않거나, 본 포스팅 이후에 작성될 예정입니다.

### viEmu CheatSheet - Lesson 1

-   [vim normal mode 커서이동 (h, j, k, l, w, W, e, E, b, B, ^, $)](https://coldmater.tistory.com/211)
-   [vim insert mode 진입 (i, a, I)](https://coldmater.tistory.com/213?category=758530)
-   vim normal mode delete & backspace ( x, backspace - X)
-   [vim 되돌리기와 재실행 (u, ^R)](https://coldmater.tistory.com/224?category=758530)
-   [vim 저장과 종료](https://coldmater.tistory.com/209?category=758530)

![](https://blog.kakaocdn.net/dn/cSlFaP/btrm3QOyC2Y/JATammApEyAAINe5sNd0kK/img.gif)

viEmu Vim Cheat Sheet Lesson 1 - http://www.viemu.com/vi-vim-tutorial-1.gif

### viEmu CheatSheet - Lesson 2

-   [vim 특정 문자로 커서 이동 (f, F, t, T)](https://coldmater.tistory.com/219?category=758530)
-   [vim 삭제하기 (d, dd)](https://coldmater.tistory.com/217?category=758530#h-tag-4)
-   [vim 수정하기 (c, cc)](https://coldmater.tistory.com/217?category=758530#h-tag-15)
-   [vim 마이크로 매크로: 직전 명령 재실행](https://coldmater.tistory.com/220?category=758530)
-   [vim 명령어 n 회 수행](https://coldmater.tistory.com/222?category=758530)
-   [vim visual mode: 블록 씌우기 (v, V, ^v)](https://coldmater.tistory.com/216?category=758530)

![](https://blog.kakaocdn.net/dn/udQUn/btrmYE2Vbbh/b7tX0gXqJsP7pjA55vHZr0/img.gif)

viEmu Vim Cheat Sheet Lesson 2 - http://www.viemu.com/vi-vim-tutorial-2.gif

🎈 n회 반복 수행은 i 에도 적용 가능함.

### viEmu CheatSheet - Lesson 3

-   [vim 복사하기와 붙여넣기 그리고 레지스터 (y, yy, p, P, ")](https://coldmater.tistory.com/218?category=758530)
-   [vim 윗줄에 입력 시작하기 (O)](https://coldmater.tistory.com/213?category=758530#h-tag-13)
-   [vim 아랫줄에 입력 시작하기 (o)](https://coldmater.tistory.com/213?category=758530#h-tag-12)

![](https://blog.kakaocdn.net/dn/rFgLJ/btrm3P9XJK0/chfUosOkMa106qgXr7mGI1/img.gif)

viEmu Vim Cheat Sheet Lesson 3 - http://www.viemu.com/vi-vim-tutorial-3.gif

### viEmu CheatSheet - Lesson 4

-   [vim 다음 찾기 (/, n, N)](https://coldmater.tistory.com/221?category=758530)
-   [vim 이전 찾기 (?, n, N)](https://coldmater.tistory.com/221?category=758530)
-   **vim 커서 위치의 단어와 동일한 다음 단어로 (*)**
-   **vim 커서 위치의 단어와 동일한 이전 단어로 (#)**

![](https://blog.kakaocdn.net/dn/JSknc/btrm5ymAjhP/Vl03qxMGDgTzVXkiRfqkV0/img.gif)

viEmu Vim Cheat Sheet Lesson 4 - http://www.viemu.com/vi-vim-tutorial-4.gif

### viEmu CheatSheet - Lesson 5

-   **vim 마킹 (m, `, ')**
-   **vim 매크로 (q, @, @@)**

![](https://blog.kakaocdn.net/dn/1XRJL/btrmXRayWJp/0xv5i9REz2jvgQ2fCr16wK/img.gif)

viEmu Vim Cheat Sheet Lesson 5 - http://www.viemu.com/vi-vim-tutorial-5.gif

### viEmu CheatSheet - Lesson 6

-   **vim 매칭되는 괄호쌍으로 이동 (%)**
-   **vim 이전, 다음 비어있는 라인으로 이동({, })**
-   **vim 현재화면 기준 상, 중, 하 위치로 커서 이동 (H, M, L)**
-   [vim 파일 끝으로 이동 (G)](https://coldmater.tistory.com/211?category=758530#h-tag-6)

다음은 필자가 판단하기에 중요하지 않음

-   **vim 이전, 다음 (0번 컬럼에 있는) 열리는 중괄호로 이동([[, ]]) - 코딩시 해당 기준을 만족하는 { 은 잘 없음**
-   [vim 문장기호(마침표) 기준 이전, 다음 문장으로 이동 ((, )) - 코딩할 때는 불필요](https://coldmater.tistory.com/211?category=758530#h-tag-7)
-   **vim 라인이동 (-, +) - j, k 와 비슷하나 다름, j, k 대신 써야할 이유 적음**
-   **vim manpage 기준 참조로 이동(K)**

![](https://blog.kakaocdn.net/dn/b2Epwz/btrm2nslX0r/C2zn3zr2yfvLJPVhFhZZNK/img.gif)

viEmu Vim Cheat Sheet Lesson 6 - http://www.viemu.com/vi-vim-tutorial-6.gif

### viEmu CheatSheet - Lesson 7

-   **vim 대소문자 변경 (~)**
-   **vim 아래 라인 현재 라인으로 합치기 (J)**
-   **vim 한 글자 수정하기(r)**
-   [vim 기타 수정 기능 (C, D, s, S)](https://coldmater.tistory.com/213?category=758530)
-   **vim 한 줄 복사하기 (Y - yy 와 동일)**
-   **vim 들여쓰기와 내어쓰기, 인덴트 컨트롤 (<, >, <<, >>, visual mode 와 조합)**
-   **vim reformat (=)**

![](https://blog.kakaocdn.net/dn/GeQ3O/btrm55YVuBO/T9nYvspZtLxpLLpVhD9Bu0/img.gif)

viEmu Vim Cheat Sheet Lesson 7 - http://www.viemu.com/vi-vim-tutorial-7.gif

## Michael's VIM Cheat Sheet

[http://michael.peopleofhonoronly.com/vim/](http://michael.peopleofhonoronly.com/vim/)

[](http://michael.peopleofhonoronly.com/vim/)

Vim Cheat Sheat for Programmers by Michael Pohoreski

Update: Version 2.0 is up! There are now 4 versions to chose from: (If you are wondering what the differences are between the screen and print: the screen has less color variations, and no gradients to make it easier to read.) <!-- Background: I couldn't f

michael.peopleofhonoronly.com

viEmu Vim Cheat Sheet 를 확장한듯한 치트시트이다. 컨트롤키까지 표현하고 있기 때문에, viEmu 보다 정교하게 vim 명령들을 담고 있다.

![](https://blog.kakaocdn.net/dn/c8D1F8/btrmXvexogA/q0MNUhEIaJj10fkYLt6jC1/img.png)

http://michael.peopleofhonoronly.com/vim/vim_cheat_sheet_for_programmers_screen.png

### 상단(키보드레이아웃) 부분 추출

우리가 기본편에서 다루지 않았던 내용은 흐리게 만들어, 우리가 살펴보지 않았던 내용만 확인할 수 있도록 만들어보자.

![](https://blog.kakaocdn.net/dn/RBH8f/btrmYdEZqDk/Kg9EEXGKKjVz3xpwNRXkbk/img.png)

치트시트의 내용 중, "[The Vim Way] 기본조작 편"에서 다루지 않은 내용들만 남겨보았다.

남은 명령 중에 주요한 것들은 다음과 같다.

-   매크로 (추후 포스팅 예정)
-   마크 관련 (추후 포스팅 예정)
-   리포맷 (=)
-   현재줄 지정하는 모션 (_)
-   기타 모션(scroll line, ↑, ↓)
-   노멀모드 또다른 복귀법 (^c)
-   : 커맨드 모드 사용 (정말 수많은 커맨드모드 명령어가 존재)
-   :s 명령어 반복 (&)
-   윈도우 관련(^w)

아래 기능들은 아쉽게도 필자도 알고 있는 기능이 아니다.

-   ? :suspend
-   ? ctags identifier - 리눅스 ctags 관련 (태그로 원하는 위치 쉽게 찾아가기?)
-   ? ctags return - 리눅스 ctags 관련 (태그로 원하는 위치 쉽게 찾아가기?)
-   ? extern filter
-   ? redraw
-   ? file/cursor info

### 하단(Legend) 부분 추출

치트시트 하단 부분에서 우리가 기본편에서 다루지 않았던 내용은 흐리게 만들어, 우리가 살펴보지 않았던 내용만 확인할 수 있도록 만들어보자. 거의 대부분을 다루지 않았다... 😅 그렇다고 주눅들 필요는 없다. 사실 아래 기능들은 필자에게도 앞으로 획득해야할 남겨진 미션이자, 이뤄야 할 과제이다. 이 연재의 목적은 IDE, 텍스트 에디터에서 라이브러리로 제공되는 Vim 의 기능을 최대한 활용하는 것이었기에, 다음 기능들은 대부분 IDE 에서 제공하는 기능들이며, 그 기능을 쓰는 것이 훨씬 효과적일 수 있음에 유의하자. 그럼에도 몇몇은 분명 알아두면 유용한 명령들이 있다.

![](https://blog.kakaocdn.net/dn/bejZBA/btrm9DBo5U4/SlkVrHCKd7XTmI2PyXJCZk/img.png)

치트시트의 내용 중, "[The Vim Way] 기본조작 편"에서 다루지 않은 내용들만 남겨보았다.

주요한 내용을 살펴보면 다음과 같다.

-   vim 매크로 (추후 포스팅 예정)
-   vim 태그 관련 (태그 리스팅, 다음/이전 태그로 이동)
-   vim 변경사항(diff) 컨트롤
-   vim 이전/다음 변경부분으로 이동
-   vim 코드 스타일 관련 제어
-   vim 코드 접기
-   vim 매칭 쌍 설정하기(% 로 이동할 때 매칭되는)
-   vim 을 여는 다양한 방법 (특정 라인 넘버에서 열기, 특정 태그에서 열기 등)
-   vim 이 열린 상태에서 다른 파일 제어하기
-   vim 좌우 이동(컬럼간 이동)
-   vim 위 아래 스크롤링
-   vim 찾아 바꾸기(추후 포스팅 예정)
-   vim 각종 설정(**보라색**)
-   vim 창(윈도우) 제어
-   vim 버퍼 제어 (Vim 속의 Vim, 임시 에디터 느낌)
-   vim 북마크
-   vim 파일 및 디렉토리 제어
-   vim insert mode 에서의 명령
-   vim 화면 스크롤링

----------

"[The Vim Way] 기본조작편"은 어쩌면, vim 의 기능을 학습하기에 너무 장황한 내용만 늘어놓은 포스팅이 되어버리지는 않았을까 하는 반성을 하게 되는 포스팅이었다. 특히 viEmu 사이트에서 제공하는 7 Lesson으로 나뉘어진 Vim 학습 단계를 하나의 커리큘럼으로 차근차근 학습해나가는 것은 Vim 을 학습하기에 매우 좋은 접근이라고 생각한다. 필자는 이 치트시트를 벽에 붙여놓고 한번씩 참고하곤 했었는데, Vim 을 사용한지 3년이 지난 지금도 모르는 명령이 있다는 사실이 새삼 신기하다.

이상으로 vim 을 사용하기 위한 첫번째 편인 '기본 조작법'을 모두 완료하였다. 이제 앞으로 총 3 섹션이 남아있다.

두번째는 심화편.

꼭 필요하지만, vim 을 조작하는데 어느정도 숙련되어야 가능한 기능들이다. 대표적으로 매크로가 있겠다.

세번째는 잡기술편.

vim 의 기능이지만, 그다지 중요하진 않은, 하지만 때론 유용할 수 있는 굴팁(꿀팁까지는 아닌... 응?)정도를 알아보도록 한다.

네번째는 응용실습편.

Vim 을 사용하기에 유용한 실무에서 실제로 발생하는 각종 상황을 가정하여 그동안 사용했던 기능들을 적용해보며 실습할 수 있도록 포스팅을 구성해볼 예정이다.




# [[The Vim Way] 14 Vim 심화편- Vim Macro (Vim 매크로)](https://coldmater.tistory.com/226)

-   coldMater
-   [개발도구 / vim](https://coldmater.tistory.com/category/%EA%B0%9C%EB%B0%9C%EB%8F%84%EA%B5%AC/vim)
-   2021. 12. 18.

드디어 Vim 의 궁극기 Macro 를 살펴볼 차례다.

## Vim 매크로

Macro 는 Vim 명령어'들'을 기록하고, 이를 반복할 수 있는 기능이다.

이전에 Vim Micro Macro(dot command)를 활용해서 이전 명령을 바로 반복할 수 있었다. 그러나, 이는 이전 명령을 반복할 뿐, '이동 후 명령' 과 같은 작업에 대해서는 그 반복이 불가능하다.

### 매크로가 필요한 순간

가령 다음 스크린샷의 좌측과 같은 코드가 있다고 가정해보자. 이를 오른쪽 코드와 같이 바꾸고자 한다. javascript 에서 key 를 그대로 value 에 넣은 뒤 이를 대문자로 바꾸려고 한다.

![](https://blog.kakaocdn.net/dn/zuCL0/btrofFxZzh0/VASazyUoL6CJLBXNFYTh9K/img.png)

Vim Macro 기능을 활용해 좌측 코드를 우측 코드와 같이 바꿔보고자 한다.

일단, jazz 가 포함된 라인(2번줄)에서 vim 을 활용하여 이 과정을 진행해보자.

다음과 같이 기존 코드를 변경할 것이다.

```
// from
jazz: ""

// to
jazz: "JAZZ"
```

이를 수행하기 위한 시퀀스는 다음과 같다.

1.  jazz 의 j 로 커서를 이동한다. (^)
2.  단어를 복사한다. (yiw)
3.  첫 번째 따옴표로 이동한다. (f")
4.  복사한 단어를 붙여넣는다. (p)
5.  붙여넣어진 단어를 대문자로 변경한다. (gUaw)  
    *참고: `gU{모션}` 은 모션 범위를 대문자로 변경한다. gu 는 소문자로.
6.  아래 줄로 이동한다. (j)

![](https://blog.kakaocdn.net/dn/ciIsxF/btrocCPLS6X/R84OnZAujkCkxCtQvNYxS1/img.gif)

key 에 해당하는 문자열을 value string 에 그대로 넣은 뒤 대문자로 변경하는 예제

위에서 설명한 1~6 과정이 그대로 반복된다면 opera 가 포함된 라인에도 동일한 동작이 수행되게 할 수 있다.

차라리 노가다를 택할 수도 있고, 굳이 매크로를 쓰지 않아도 적절히 몇번 반복하면 끝난다고 생각할 수도 있겠지만, 동일한 작업을 해야하는 라인이 수십줄이 넘어간다고 상상해보자.

매크로를 활용하지 못한다면, 각 라인마다 각각 12회의 키를 입력해야 한다.

일련의 동작들을 기록하고 재사용할 수 있다면 어떨까? 그게 바로 Vim Macro 이다.

### Vim Macro

-   `q{레지스터}` 로 매크로 기록 시작
-   `q` 로 매크로 기록 종료
-   `@{레지스터}` 로 저장된 매크로 실행
-   `@@` 로 직전에 실행한 매크로 재실행
-   `{반복횟수}@{레지스터}` 또는 `{반복횟수}@@` 로 저장된 매크로를 '반복횟수' 만큼 재실행

#### q - Vim Macro 기록하기 & 기록 종료하기

Normal Mode 에서 q 를 입력하면, 하단 상태표시줄에 q 가 표시된다. 이는 앞으로 기록할 레지스터를 지정해주기를 대기하고 있는 상태이다. 레지스터(a-z, 0-9 중 하나)를 정하여 입력하면 상태표시줄에 'Recording @a'(레지스터로 'a'를 입력했다고 가정) 와 같이 실제 명령어를 대기하고 있는 상태가 된다.

일련의 동작들을 입력한 뒤 다시 q 를 입력하면 매크로 기록이 종료된다.

다음 스크린샷에서 위에서 1~6 과정에서 입력한 과정들을 매크로로 기록하는 과정을 살펴보자.

![](https://blog.kakaocdn.net/dn/d1L7KG/btrobTq95Ow/sMn2K1THV3gGqDKVetdC31/img.gif)

qa 명령어로 a 레지스터에 일련의 동작들을 기록한 뒤 q 명령어로 기록을 중지했다. (기록상황은 하단 상태표시줄에 나타난다.)

이 예제에서는 매크로를 기록할 레지스터로 a 를 사용했다.

#### @ - Vim Macro 실행하기

`@{레지스터}` 로 특정 레지스터에 저장된 매크로를 실행시킬 수도 있고, `@@` 로 직전에 실행한 매크로를 재실행할 수도 있다.

"opera" 라인(3번줄)은 `@a` 로 재실행해보자. 이전 스크린샷에서 그대로 이어진다.

![](https://blog.kakaocdn.net/dn/9d81f/btrodmsk2Zb/E5536S8x1jQ3vHqEDkTCPK/img.gif)

@{매크로가 저장된 레지스터}를 통해 저장된 매크로를 실행시킨다.

rock 라인은(4번줄)은 `@@` 로 직전에 실행한 매크로를 반복해보자. 이전 스크린샷에서 그대로 이어진다.

(@ 이 두 번 눌러진다는것을 보여주기 위해 @과 @ 사이에 약간의 딜레이를 주었다.)

![](https://blog.kakaocdn.net/dn/5dQ0Y/btrobTEE1IC/kuNRPce4evygBbBJbofKr0/img.gif)

@@ 는 직전에 실행된 매크로를 재실행한다.

이렇게 매크로를 알아보았다. 사실 이렇게 매크로를 활용하는 것이 거의 전부이다. (쓸 데 없을지도 모르지만) 매크로와 관련하여 몇가지 사항을 아래에서 더 알아보도록 하자.

#### 레지스터에 저장된 매크로 확인해보기

vim 에서는 레지스터에 저장된 내용을 확인하기 위한 command mode 명령어를 제공한다. `:register` 가 그것이다. 단순히 이 명령어를 입력하면 모든 레지스터의 저장된 값들을 리스팅해준다. ':register' 명령어는 인자를 받기도 하는데, `:register a` 와 같이 명령어의 인자로 레지스터명을 전달하면 해당 레지스터에 저장된 값을 표현해준다. (오리지널 vim 에서도 UI 만 다를 뿐 VSCode Vim 과 동일하게 동작한다.)

![](https://blog.kakaocdn.net/dn/ZrY9n/btrodTi8V8R/SNsYU46rm1ocGczKkMZTa0/img.gif)

VSCode Vim 에서 `:register` 커맨드 모드 명령어로 레지스터의 내용을 확인하는 모습, a 레지스터에 우리가 저장한 동작이 보인다.

![](https://blog.kakaocdn.net/dn/4sA4R/btroezkr0ks/QKfnf2XWUO1pOs22RNX6Ak/img.gif)

`:register a` 명령어를 입력하여 a 레지스터에 저장된 내용을 확인하는 모습, 우리가 위 과정을 통해 저장한 일련의 동작들이 확인된다.

레지스터에 저장된 내용이기 때문에, 당연하게도 `"ap` 명령어로 a 레지스터의 내용을 붙여넣을 수 있다. (이게 가능한 이유가 궁금하다면  [2021.11.14 - [개발도구/vim] - [The Vim Way] 06 Vim 기본조작 - Vim 복사하기와 붙여넣기 그리고 레지스터](https://coldmater.tistory.com/218)  를 참고하도록 하자.)

![](https://blog.kakaocdn.net/dn/2OkIs/btrodSq0w08/31BkOtiAC94AiEjCKYRQy0/img.gif)

레지스터를 지정하여("a) 붙여넣기(p)를 수행한 모습이다. 우리가 매크로로 기록했던 내용이 붙여넣어졌다.

매크로는 레지스터에 저장된다는 점을 활용하여 복잡한 매크로의 경우 .vimrc 등의 파일에 등록하여 관리하기도 한다.

## Vim Macro 활용하기

### 반복자와 함께 활용하기

매크로도 하나의 명령이기 때문에, 매크로를 실행하기 전에 반복횟수를 지정할 수 있다.

단어와 단어는 tab 문자로 구분되어있는 다음과 같은 데이터가 있다.

```
1	one	first
2	two	second
3	three	third
4	four	fourth
5	five	fifth
6	six	sixth
7	seven	seventh
8	eight	eighth
9	nine	ninth
10	ten	tenth
11	eleven	eleventh
12	twelve	twelfth
13	thirteen	thirteenth
14	fourteen	fourteenth
15	fifteen	fifteenth
16	sixteen	sixteenth
17	seventeen	seventeenth
18	eighteen	eighteenth
19	nineteen	nineteenth
20	twenty	twentieth
21	twenty-one	twenty-first
22	twenty-two	twenty-second
23	twenty-three	twenty-third
24	twenty-four	twenty-fourth
25	twenty-five	twenty-fifth
26	twenty-six	twenty-sixth
27	twenty-seven	twenty-seventh
28	twenty-eight	twenty-eighth
29	twenty-nine	twenty-ninth
30	thirty	thirtieth
31	thirty-one	thirty-first
40	forty	fortieth
50	fifty	fiftieth
60	sixty	sixtieth
70	seventy	seventieth
80	eighty	eightieth
90	ninety	ninetieth
100	one hundred	hundredth
```

이 데이터를 가공하여 각 라인을 다음과 같이 처리하고자 한다.

```
// from
1	one	first

// to
const ONE = 1; // first number
```

이를 매크로를 기록하고 모든 라인에 적용해보도록 하자.

먼저 기록하는 화면을 보도록 하자.

![](https://blog.kakaocdn.net/dn/bvaZQI/btrobNR40Pa/RnFgNC72Kpi0h6vev1svc1/img.gif)

첫번째 줄을 요구사항대로 가공하는 동작을 매크로에 기록하는 장면

이제 이 매크로를 나머지 라인들에 적용해보자.

![](https://blog.kakaocdn.net/dn/bigPwI/btrn8IDJLQI/44amvW7wZhn1mWFJ4QBg0K/img.gif)

100@@ 로 나머지 라인들에 대해 매크로를 일괄 적용할 수 있다.

이와 같이 '충분한' 숫자를 반복횟수로 지정하여 남아있는 처리 대상에 대해 매크로가 적용되게 할 수 있다. 매크로는 더 이상 진행될 수 없으면 그 동작을 멈추므로 실제로는 37 라인밖에 되지 않지만, `100@@` 와 같이 '충분한' 반복횟수를 지정하는 것으로 편리하게 '나머지 대상 전부'를 지정할 수 있다.

위 스크린샷의 경우처럼 100 의 경우 그 처리가 제대로 되지 않은것을 확인할 수 있는데(one hundred 만 이름 사이에 공백이 들어가있음), 매크로를 기록할 때 이러한 다양한 상황까지 고려하여 작성해주어야 할 필요가 있을 수 있다.

----------

매크로는 동일한 이름을 공유하는 마이크로 매크로(dot command)보다는 그 활용도가 낮다고 할 수 있다. 매크로는 위에서 본 것과 같이 '복잡한 시퀀스'를 '여러번 수행'하여야 할 때 그 진가를 발휘한다. 간혹 코딩을 하다보면, 이러한 요구사항이 생기기 마련인데, 그럴 때마다 vim 에서 macro 를 어떻게 수행했는지 검색해보면 그만이다. 그러니 부담을 갖지 말고, 그러한 상황에 매크로가 있었다는 사실을 기억하고 적용해볼 수 있었으면 좋겠다.

다음 시간에는 커맨드모드에서 수행할 수 있는 다양한 명령어 중에 하나인 (그리고 사실 이 연재에서 다루는 몇 안되는 커맨드모드 명령어중에 하나인) '찾아바꾸기' 기능을 소개하도록 하겠다.


# [[The Vim Way] 15 Vim 심화편- Vim 찾아 바꾸기 (substitute)](https://coldmater.tistory.com/227)

-   coldMater
-   [개발도구 / vim](https://coldmater.tistory.com/category/%EA%B0%9C%EB%B0%9C%EB%8F%84%EA%B5%AC/vim)
-   2021. 12. 20.

이번 시간에는 Vim 에서 어떻게 '찾아 바꾸기'를 하는지 알아보도록 하자. 'Vim 에서 찾기' 기능은 앞선 '기본조작'편에서 이미 알아보았다. '찾기'는  [[The Vim Way] 09 Vim 기본조작 - Vim 문자열 찾기](https://coldmater.tistory.com/221) 편에서 알아볼 수 있다.

## Vim 찾아 바꾸기

요즘 IDE 또는 텍스트에디터에서는 '찾아 바꾸기'는 매우 기본적으로 탑재되어있는 기능 중에 하나이다. 특히 jetbrains 계열의 IDE 에서는 정규표현식, 대소문자 구분 여부, 단일 단어 여부에 따라 찾기 및 찾아바꾸기 기능을 지원한다. 즉, vim 에서 제공하는 찾아바꾸기를 굳이 이용할 이유가 없는 것도 사실이지만, original vim 을 이용해야하는 상황이거나, 범위를 지정하여 찾아바꾸기를 진행해야 하는 경우 등의 상황이라면 이번 포스팅에서 다룬 내용이 유용할 수 있을 것이다. 이 포스팅은 '과도하게(?) 자세히' 본 기능에 대해서 소개한다.  **바쁜 당신을 위해 바로 아래 '빠르게 살펴보기'를 준비했다.**

### Vim 찾아바꾸기 Quick View

Normal 모드에서 다음을 입력하면 문서 전체에 대하여 나타나는 모든 'something' 을 'sth' 로 변경한다.

(대소문자 관계 없이 - case insenstive - 하게 변경하고자 한다면, g 뒤에 i 를 덧붙여준다.)

```
:%s/something/sth/g
```

아래는 이 명령의 동작 원리를 상세하게 풀어 설명한다.

### Vim 찾아 바꾸기 기본 (현재 라인)

vim 에서 찾아 바꾸기는 '커맨드모드'에서 이루어진다. 커맨드모드에서 다음 명령어를 입력하여  **현재 커서가 위치하는 라인에 대하여 '찾아 바꾸기'**를 수행할 수 있다.

-   `:` 로 커맨드모드 진입
-   `s/{찾을 대상 regex}/{바꿀 문자열}` 입력

`:s` 는 커맨드모드에서 '찾아바꾸기'를 의미하는 명령이다. (substitute 의 첫 글자)

첫 번째 슬래시(/) 이후에는 '찾을 문자열(정규표현식)'을 입력한다. (보통 pattern 이라고 표기한다.)

두 번째 슬래시(/) 이후에는 '바꿀 문자열'을 입력한다.

가령 다음과 같이 입력하면 'show' 라는 문자열을 'give' 라는 문자열로 변경하는 명령어를 의미하게 된다.  단, 커서가 위치한 라인만 해당 사항이 적용된다는 것과, '찾을 대상'으로 지정한 첫 번째 대상만 (정규식의 특징) 변경된다는 점에 유의한다.

```
:s/show/give
```

![](https://blog.kakaocdn.net/dn/llp4k/btrodmG84nA/IoTgVbnU5HPxFpM22W38O1/img.gif)

:s/show/take 를 입력하자 커서가 위치한 라인의 show 가 take 로 변경되었다.

'찾을 대상'은 사실 정규표현식을 지정하는 곳이다. 다음처럼 입력하면 'w 로 시작하는 단어(regex: /[w]\w+)'를 모두 'path' 로 변경해준다.

```
:s/[w]\w+/path
```


# [[The Vim Way] 16 Vim 심화편- Vim Surround](https://coldmater.tistory.com/228)

-   coldMater
-   [개발도구 / vim](https://coldmater.tistory.com/category/%EA%B0%9C%EB%B0%9C%EB%8F%84%EA%B5%AC/vim)
-   2021. 12. 20.

Vim 생태계에는 surround 라는 플러그인이 존재한다. 이는 vim 에서 괄호를 컨트롤할 수 있는 강력한 기능을 제공한다.

[https://github.com/tpope/vim-surround](https://github.com/tpope/vim-surround)

[](https://github.com/tpope/vim-surround)

GitHub - tpope/vim-surround: surround.vim: Delete/change/add parentheses/quotes/XML-tags/much more with ease

surround.vim: Delete/change/add parentheses/quotes/XML-tags/much more with ease - GitHub - tpope/vim-surround: surround.vim: Delete/change/add parentheses/quotes/XML-tags/much more with ease

github.com

위 링크를 통해서 사실상 surround 플러그인 설치법, 사용법을 모두 익힐 수 있다.

## Vim Plugin Surround

surround 는 vim 의 유명한 플러그인 중의 하나이다. VSCode Extension 인 Vim 에서는 surround 를 기본 플러그인으로 제공하고 있을정도로 유명한 플러그인이다.

### surround 적용하기

웬만한 IDE 의 Vim Extension 은 surround 를 기본 플러그인으로 탑재하고 있다. 다만, 활성되지 않은 상태로 존재하는데, surround 를 활성화시키는 방법은 다음과 같다. (상술했듯이, VSCode 에서는 이 명령 없이도 기본적으로 surround 가 활성화되어있다.)

```
:set surround
```

다만, 이렇게 surround 를 활성시키는 경우 IDE 또는 Vim 을 실행시킬 때마다 해당 명령을 입력해주어야 한다는 것인데, vimrc(vim 설정 파일) 파일에 surround 플러그인이 항상 활성화되도록 지정할 수도 있다. 운영체제, IDE 별로 설정법이 다르므로 이에 대한 자세한 설명은 다음 글을 참조하도록 하자.  [https://github.com/johngrib/simple_vim_guide/blob/master/md/vimrc.md](https://github.com/johngrib/simple_vim_guide/blob/master/md/vimrc.md)

[](https://github.com/johngrib/simple_vim_guide/blob/master/md/vimrc.md)

GitHub - johngrib/simple_vim_guide: simple vim guide

simple vim guide. Contribute to johngrib/simple_vim_guide development by creating an account on GitHub.

github.com

### surround 로 할 수 있는 일

먼저 surround 의 의미대로 '감싸는'대상은 surround 플러그인의 제어 대상이다.

**surround 의 제어 대상**

-   괄호 (, {, [, ], }, )
-   따옴표 ', ", `
-   태그 <any>

먼저, surround 플러그인으로 어떤 동작을 수행할 수 있는지 알아보는게 순서일 것 같다. surround 를 활용해서 다음과 같은 일들을 수행할 수 있다.

**surround 로 할 수 있는 일 (surround 는 surround 의 제어 대상(위)을 의미한다.)**

-   `ys{모션}{씌울 surround}` - surround 씌우기  
    💡 이 동작은 visual 모드로부터 `S` 명령어로도 진입이 가능하다.
-   `ds{지울 surround}` - surround 지우기
-   `cs{모션}` - surround 변경

## Vim Surround with GIF

[surround 의 github 페이지](https://github.com/tpope/vim-surround)에 모든 내용이 축약되어있으므로, 여기서 surround 의 기능을 상세히 소개하기보다, gif 스크린샷으로 어떤 일들을 할 수 있는지 간략히 살펴보도록 하자.

### ys - surround 씌우기

`ys{모션}{surround}` 명령어로 대상을 지정한 surround 로 감쌀 수 있다. 닫히는 괄호를 사용하면, 괄호 안쪽에 공백이 포함되지 않는다.

```
ys3w)
```

![](https://blog.kakaocdn.net/dn/cumqmS/btrodR8bJhs/OxiO0ymcT7jjskEEHl53E1/img.gif)

vim surround - surround with closing bracket: ys3w

열리는 괄호를 활용하면 괄호와 감싸는 대상 사이에 공백이 포함된다.

```
ys3w(
```

![](https://blog.kakaocdn.net/dn/xaRym/btrodAkBuMK/MDRLN16CggRCmgZKWahRck/img.gif)

vim surround - surround with opening bracket: ys3w(

필자는 자주 사용하는 기능은 아니지만, 태그를 씌울 수도 있다. 속성을 함께 기입하더라도 문제 없다.

> 💡 아무래도 이 기능은 VSCode Extension Vim(v1.21.10) 에서는 정상적으로 작동하지 않는 것 같아 보입니다. intelliJ 의 Vim Extension 에서 동작하는 모습으로 대체합니다. 태그 surround 에 관하여는 제 컴퓨터 환경에서 VSCode, IntelliJ, (Original) Vim 모두에서 의도치 않은 동작들을 서로 다른 모습으로 보여주었습니다.

```
ys$<div class="line">
```

![](https://blog.kakaocdn.net/dn/dQYlL8/btrohSLZSyU/OQSto1he6T02LYLhDlKbRk/img.gif)

태그로 surround 하는 예제이다. 이 동작은 dot command 로 반복이 가능하다. (하지만 태그에 관련한 동작은 아직 완벽하지 않다.)

### ds - surround 지우기

vim 은 자체적으로 감싸는 대상을 모두 지우기가 가능했다. `da{감싸는 대상}` 또는 `di{감싸는 대상}` 으로 그 동작이 가능했다. 만약 괄호만 지우고 싶거나, 따옴표만 지우고 싶다면? 정확히 괄호 즉, 감싸는 대상만을 지우는 기능은 surround 에서 제공한다.

열리는 괄호는 '공백 포함'을 의미하므로, 커서가 위치한 곳에 포함된 괄호를 안쪽 공백을 포함하여 삭제할 수 있다.

```
ds(
```

![](https://blog.kakaocdn.net/dn/37tvN/btrops6kjgK/ATKlcFvMGOizX9dj9JIAmK/img.gif)

vim surround - de-surround with opening bracket: ds(

마찬가지로 닫히는 괄호를 활용하면 양쪽 공백을 포함하지 않고 괄호만 지우기도 가능하다.

```
ds)
```

![](https://blog.kakaocdn.net/dn/6xeKg/btrodSTviSw/rPBkmKFKo7zG9OwYxY11Y0/img.gif)

vim surround - de-surround with closing bracket: ds)

### cs - surround 바꾸기

surround 를 변경하기도 가능하다. 특히 따옴표 ', ", ` 사이에 변환하는 경우 유용하다.

다음 코드는 홑따옴표 `'`로 감싸진 영역을 쌍따옴표 `"`로 변경하는 명령이다. `cs{FROM surround}{TO surround}` 형태로 사용할 수 있다.

```
cs'"
```



<!--stackedit_data:
eyJoaXN0b3J5IjpbLTE1MTQ2OTIxOTYsMTY0MDY3MzA1NCwtMT
Q1NTA0NjY5NCwtMTY0MTA1MTkzMiw3MzA5OTgxMTZdfQ==
-->